<!DOCTYPE html>
<html>
	<head>
		<!--
Copyright (c) 2014, 2015  StorPool.
All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

		-->
		<title>StorPool API Reference</title>
		<style>
			pre {
				border: 1px dashed #333333;
				padding: 1em;
				margin-top: 5px;
				margin-bottom: 5px;
				overflow: auto;
				width: 95%;
				color: #000066;
			}
			
			pre var {
				font-weight: bold;
				color: #FF0000;
			}
			
			strong {
				font-style: italic;
				color: #000066;
			}
			
			li.attribute {
				margin-bottom: 0.2em;
			}
			table {
				position: relative;
				left: 20px;
				border-collapse: collapse;
			}
			td {
				border-bottom: 1px dashed #aaa;
			}
			
			pre.code {
				position: relative;
				left: 50px;
			}
			.opt {
				font-style: italic;
				font-weight: bold;
			}
			
			pre .opt {
				color: #444;
			}
		</style>
	</head>
	<body>
	
<h1>StorPool API Reference</h1>
<p>Copyright (c) 2014 - 2018  StorPool. All rights reserved.</p>
<p>This reference document describes the StorPool API version 18.02 and
the supported API calls.</p>
<ol>
<li><a href="#General">General</a></li>
<ol>
</ol>
<li><a href="#Peers">Peers</a></li>
<ol>
<li><a href="#NetworkPeersList">List the network peers</a></li>
</ol>
<li><a href="#Tasks">Tasks</a></li>
<ol>
<li><a href="#TasksList">List tasks</a></li>
</ol>
<li><a href="#Services">Services</a></li>
<ol>
<li><a href="#ServicesList">List all StorPool services</a></li>
<li><a href="#ServersListBlocked">List all blocked StorPool servers</a></li>
</ol>
<li><a href="#Servers">Servers</a></li>
<ol>
<li><a href="#ServerDisksList">List all disks on a server</a></li>
<li><a href="#ServerDiskDescribe">Describe a disk on a server</a></li>
</ol>
<li><a href="#Clients">Clients</a></li>
<ol>
<li><a href="#ClientsConfigDump">Get the current status of all the clients</a></li>
<li><a href="#ClientConfigWait">Wait until a client updates to the current configuration</a></li>
<li><a href="#ClientActiveRequests">List all the active requests on a client</a></li>
</ol>
<li><a href="#Disks">Disks</a></li>
<ol>
<li><a href="#DisksList">List all disks</a></li>
<li><a href="#DiskDescribe">Describe a disk</a></li>
<li><a href="#DiskGetInfo">Get disk info</a></li>
<li><a href="#DiskEject">Eject a disk</a></li>
<li><a href="#DiskForget">Forget a disk</a></li>
<li><a href="#DiskIgnore">Ignore a disk</a></li>
<li><a href="#DiskSoftEject">Soft-eject a disk</a></li>
<li><a href="#DiskSoftEjectPause">Pause a disk&apos;s soft-eject operation</a></li>
<li><a href="#DiskSoftEjectCancel">Cancel a disk&apos;s soft-eject operation</a></li>
<li><a href="#DiskSetDescription">Set a disk&apos;s description</a></li>
<li><a href="#DiskActiveRequests">List all the active requests on a disk</a></li>
<li><a href="#DiskScrubStart">Start scrubbing process</a></li>
<li><a href="#DiskScrubPause">Pause scrubbing process</a></li>
<li><a href="#DiskScrubContinue">Continue paused scrubbing process</a></li>
<li><a href="#DiskRetrim">Retrim disk</a></li>
</ol>
<li><a href="#Volumes">Volumes</a></li>
<ol>
<li><a href="#VolumesList">List all volumes</a></li>
<li><a href="#VolumesGetStatus">Get volume and snapshot status</a></li>
<li><a href="#VolumesSpace">List total used space by each volume</a></li>
<li><a href="#Volume">List a single volume</a></li>
<li><a href="#VolumeDescribe">Describe a volume</a></li>
<li><a href="#VolumeGetInfo">Get volume info</a></li>
<li><a href="#VolumeListSnapshots">List the parent snapshots of a volume</a></li>
<li><a href="#VolumeCreate">Create a new volume</a></li>
<li><a href="#VolumeUpdate">Update a volume</a></li>
<li><a href="#VolumeFreeze">Freeze a volume</a></li>
<li><a href="#VolumeRebase">Rebase a volume</a></li>
<li><a href="#VolumeAbandonDisk">Abandon disk</a></li>
<li><a href="#VolumeDelete">Delete a volume</a></li>
<li><a href="#VolumeBackup">Backup a volume to a remote location</a></li>
<li><a href="#VolumesGroupBackup">Backup a group of volumes to a remote location</a></li>
</ol>
<li><a href="#Snapshots">Snapshots</a></li>
<ol>
<li><a href="#SnapshotsList">List all snapshots</a></li>
<li><a href="#SnapshotsSpace">List snapshots space estimations</a></li>
<li><a href="#Snapshot">List a single snapshot</a></li>
<li><a href="#SnapshotDescribe">Describe a snapshot</a></li>
<li><a href="#SnapshotGetInfo">Get snapshot info</a></li>
<li><a href="#VolumeSnapshot">Snapshot a volume</a></li>
<li><a href="#SnapshotUpdate">Update a snapshot</a></li>
<li><a href="#SnapshotRebase">Rebase a snapshot</a></li>
<li><a href="#VolumeAbandonDisk">Abandon disk</a></li>
<li><a href="#SnapshotDelete">Delete a snapshot</a></li>
<li><a href="#SnapshotDeleteById">Delete a snapshot by global id</a></li>
<li><a href="#VolumesGroupSnapshot">Create consistent snapshots of a group of volumes</a></li>
<li><a href="#SnapshotFromRemote">Copy a snapshot from a remote location</a></li>
<li><a href="#SnapshotExport">Allow a remote location to access a local snapshot</a></li>
<li><a href="#SnapshotUnexport">Revoke a remote location&apos;s access to a local snapshot</a></li>
<li><a href="#ExportsList">List exported snapshots</a></li>
<li><a href="#SnapshotsRemoteList">List the available remote snapshots</a></li>
<li><a href="#SnapshotsRemoteUnexport">Instruct the remote location that we will no longer use those snapshots</a></li>
</ol>
<li><a href="#Attachments">Attachments</a></li>
<ol>
<li><a href="#AttachmentsList">List all attachments</a></li>
<li><a href="#VolumesReassign">Reassign volumes and/or snapshots</a></li>
<li><a href="#VolumesReassignWait">Reassign volumes and/or snapshots with confirmation from the clients</a></li>
</ol>
<li><a href="#Placement-Groups">Placement Groups</a></li>
<ol>
<li><a href="#PlacementGroupsList">List all placement groups</a></li>
<li><a href="#PlacementGroupDescribe">Describe a single placement group</a></li>
<li><a href="#PlacementGroupUpdate">Create and/or update a placement group</a></li>
<li><a href="#PlacementGroupDelete">Delete a placement group</a></li>
<li><a href="#FaultSetsList">List all fault sets</a></li>
</ol>
<li><a href="#Volume-Templates">Volume Templates</a></li>
<ol>
<li><a href="#VolumeTemplatesList">List all volume templates</a></li>
<li><a href="#VolumeTemplatesStatus">List the status of all volume templates</a></li>
<li><a href="#VolumeTemplateDescribe">Describe a single volume template</a></li>
<li><a href="#VolumeTemplateCreate">Create a volume template</a></li>
<li><a href="#VolumeTemplateUpdate">Update a volume template</a></li>
<li><a href="#VolumeTemplateDelete">Delete a volume template</a></li>
</ol>
<li><a href="#Volume-Relocator">Volume Relocator</a></li>
<ol>
<li><a href="#VolumeRelocatorStatus">Get the relocator&apos;s status</a></li>
<li><a href="#VolumeRelocatorDisksList">List total per disk relocation estimates</a></li>
<li><a href="#VolumeRelocatorVolumeDisks">List per disk relocation estimates for a given volume</a></li>
<li><a href="#VolumeRelocatorSnapshotDisks">List per disk relocation estimates for a given snapshot</a></li>
</ol>
<li><a href="#Balancer">Balancer</a></li>
<ol>
<li><a href="#VolumeBalancerStatus">Get the balancer&apos;s status</a></li>
<li><a href="#VolumeBalancerStatus">Set the balancer&apos;s status</a></li>
<li><a href="#VolumeBalancerVolumesStatus">List balancer volume and snapshot status</a></li>
<li><a href="#VolumeBalancerDisksList">List total per disk rebalancing estimates</a></li>
<li><a href="#VolumeBalancerVolumeDisks">List per disk rebalancing estimated for a given volume</a></li>
<li><a href="#VolumeBalancerSnapshotDisks">List per disk rebalancing estimates for a given snapshot</a></li>
<li><a href="#VolumeBalancerVolumeDiskSets">Get the disk sets computed by the balancer for a given volume</a></li>
<li><a href="#VolumeBalancerSnapshotDiskSets">Get the disk sets computed by the balancer for a given snapshot</a></li>
<li><a href="#VolumeBalancerGroups">List balancer allocation groups</a></li>
</ol>
<li><a href="#iSCSI">iSCSI</a></li>
<ol>
<li><a href="#iSCSIConfig">Get the StorPool iSCSI configuration</a></li>
<li><a href="#iSCSIConfig">Modify the StorPool iSCSI configuration</a></li>
</ol>
<li><a href="#Remote">Remote</a></li>
<ol>
<li><a href="#LocationsList">List the registered remote locations</a></li>
</ol>
<li><a href="#types">Data Types</a></li>
</ol>
<h2 id="General">General</h2>
<p>The StorPool API can be used with any tool that can generate HTTP requests with the GET and POST methods.
The only requirement is to supply the Authorization header and, if required by the request, valid JSON data.</p>
<p>For each call there is an explanation of the HTTP request and response
and an example in raw format as it should be sent to the StorPool management service.</p>
<p>Here are two examples using curl using the GET and POST methods respectively and their counterparts as issued by the StorPool CLI:</p>
<p></p>
<pre class="code"><code>curl -H &quot;Authorization: Storpool v1:1556129910218014736&quot; 192.168.42.208:81/ctrl/1.0/DisksList
storpool disk list
</code></pre>
<p></p>
<p></p>
<pre class="code"><code>curl -d &apos;{&quot;addDisks&quot;:[&quot;1&quot;]}&apos; -H &quot;Authorization: Storpool v1:1556129910218014736&quot; 192.168.42.208:81/ctrl/1.0/PlacementGroupUpdate/hdd
storpool placementGroup hdd addDisk 1
</code></pre>
<p></p>
<p>Python programs may use the API by importing the Python StorPool bindings (use &apos;pypi install storpool&apos; to install them):</p>
<p></p>
<pre class="code"><code># Use the default StorPool configuration settings

&gt;&gt;&gt; from storpool import spapi
&gt;&gt;&gt; api=spapi.Api.fromConfig()

# Use an already-created spconfig.SPConfig object
&gt;&gt;&gt; api=spapi.Api.fromConfig(cfg=cfg)

# Explicitly specify the hostname, port, and authentication string
&gt;&gt;&gt; api=spapi.Api(host=&apos;192.168.0.5&apos;, port=80, auth=&apos;1556560560218011653&apos;)

# Use the created API access object
&gt;&gt;&gt; api.peersList()

{
  1: {
       &apos;networks&apos;: {
         0: {
          &apos;mac&apos;: &apos;00:4A:E6:5F:34:C3&apos;
         }
       }
  },
  2: {
       &apos;networks&apos;: {
         0: {
          &apos;mac&apos;: &apos;52:54:E6:5F:34:DF&apos;
         }
       }
  },
  3: {
        &apos;networks&apos;: {
          0: {
           &apos;mac&apos;: &apos;52:57:5F:54:E6:3A&apos;
          }
        }
  }
}
</code></pre>
<p></p>
<p>The calls that may be used may be found in the file spapi.py.  As a rule of
thumb, the name of the call is the name of the HTTP query with the first
letter in lowercase (as above: &quot;peersList()&quot; for the &quot;PeersList&quot; query).
To view them all once the StorPool bindings are installed, run a Python
interpreter and then:</p>
<p></p>
<p></p>
<pre class="code"><code>&gt;&gt;&gt; from storpool import spapi
&gt;&gt;&gt; help(spapi)
</code></pre>
<p></p>
<p>Note: Requests will sometimes use GET instead of POST and consequently,
will not require JSON. Responses on the other hand always produce JSON content.</p>
<h2 id="Peers">Peers</h2>
<p></p>
<h3 id="NetworkPeersList">List the network peers (<strong>NetworkPeersList</strong>)</h3>
<p>List the network nodes running the StorPool beacon including information
	such as the ID of the node,
	the networks it communicates through and the corresponding MAC addresses.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/NetworkPeersList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/NetworkPeersList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>PeerID</var>": {
      "beaconStatus": <var>BeaconNodeStatus</var>,
      "clusterStatus": <var>BeaconClusterStatus</var>,
      "joined": <var>bool</var>,
      "networks": {
        "<var>NetID</var>": {
          "mac": <var>MAC Address</var>
        }, ...
      } <span class="opt">/* Optional */</span>,
      "nonVoting": <var>bool</var>,
      "rdma": {
        "<var>NetID</var>": {
          "guid": <var>GUID</var>,
          "state": <var>RdmaState</var>
        }, ...
      }
    }, ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from PeerID to PeerDesc
<ul>
<li>Key type: <strong><a href="#PeerID">PeerID</a></strong></li>
<li>Value type: <strong>PeerDesc</strong><ul>
<li class="attribute">beaconStatus:  (<strong><a href="#BeaconNodeStatus">BeaconNodeStatus</a></strong>): Whether a beacon is running at all on this node.</li><li class="attribute">clusterStatus:  (<strong><a href="#BeaconClusterStatus">BeaconClusterStatus</a></strong>): Whether we consider this node a part of the cluster quorum.</li><li class="attribute">joined:  (<strong><a href="#bool">bool</a></strong>): Whether the node considers itself a part of the cluster quorum.</li><li class="attribute">networks:  (<span class="opt">Optional</span> <strong><a href="#{NetID: NetDesc}">{NetID: NetDesc}</a></strong>): List of the Ethernet networks that StorPool communicates through on this node.</li><li class="attribute">nonVoting:  (<strong><a href="#bool">bool</a></strong>): Whether this is a non-voting StorPool node (e.g. client only).</li><li class="attribute">rdma:  List of the RDMA networks that StorPool communicates through on this node.A dict from NetID to RdmaDesc
<ul>
<li>Key type: <strong><a href="#NetID">NetID</a></strong></li>
<li>Value type: <strong>RdmaDesc</strong><ul>
<li class="attribute">guid:  (<strong><a href="#GUID">GUID</a></strong>)</li><li class="attribute">state:  (<strong><a href="#RdmaState">RdmaState</a></strong>)</li></ul>
</li>
</ul>
</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Tasks">Tasks</h2>
<p></p>
<h3 id="TasksList">List tasks (<strong>TasksList</strong>)</h3>
<p>List the currently active recovery tasks. This call will return JSON
	data only when there is a relocation in progress. Under normal operation
	of the cluster it will return no data.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/TasksList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/TasksList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "allObjects": <var>int</var>,
    "completedObjects": <var>int</var>,
    "diskId": <var>DiskID</var>,
    "dispatchedObjects": <var>int</var>,
    "transactionId": <var>long</var>,
    "unresolvedObjects": <var>int</var> <span class="opt">/* Internal */</span>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>Task</strong><ul>
<li class="attribute">allObjects:  (<strong><a href="#int">int</a></strong>): The number of all the objects that the task is performing actions on.</li><li class="attribute">completedObjects:  (<strong><a href="#int">int</a></strong>): The number of objects that the task has finished working on.</li><li class="attribute">diskId:  (<strong><a href="#DiskID">DiskID</a></strong>): The disk ID this task is on.</li><li class="attribute">dispatchedObjects:  (<strong><a href="#int">int</a></strong>): Objects that the task has started working on.</li><li class="attribute">transactionId:  (<strong><a href="#long">long</a></strong>): An ID associated with the currently running task. This ID is the same for all the tasks running on different disks but initiated by the same action (e.g. when reallocating a volume, all tasks associated with that volume will have the same ID).</li><li class="attribute">unresolvedObjects:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Services">Services</h2>
<p></p>
<h3 id="ServicesList">List all StorPool services (<strong>ServicesList</strong>)</h3>
<p>List all the services in the cluster (StorPool servers, clients, management, etc).
	If the whole cluster is
	not operational this call will return an error.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ServicesList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ServicesList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "bridges": {
      "<var>BridgeId</var>": {
        "id": <var>BridgeId</var>,
        "nodeId": <var>NodeID</var>,
        "startTime": Either(<var>null</var>, <var>int</var>),
        "status": <var>BridgeStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "clients": {
      "<var>ClientID</var>": {
        "id": <var>ClientID</var>,
        "nodeId": <var>NodeID</var>,
        "startTime": Either(<var>null</var>, <var>int</var>),
        "status": <var>ClientStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "clusterStatus": <var>ClusterStatus</var>,
    "mgmt": {
      "<var>MgmtID</var>": {
        "active": <var>bool</var>,
        "id": <var>MgmtID</var>,
        "nodeId": <var>NodeID</var>,
        "prio": <var>int</var> <span class="opt">/* Internal */</span>,
        "startTime": Either(<var>null</var>, <var>int</var>),
        "status": <var>ClientStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "servers": {
      "<var>ServerID</var>": {
        "id": <var>ServerID</var>,
        "missingDisks": [<var>DiskID</var>, ...],
        "nodeId": <var>NodeID</var>,
        "pendingDisks": [<var>DiskID</var>, ...],
        "startTime": Either(<var>null</var>, <var>int</var>),
        "status": <var>ServerStatus</var>,
        "version": <var>string</var>
      }, ...
    }
  }
}
</code></pre></li>
<li>Response Data:
<strong>ClusterStatus</strong><ul>
<li class="attribute">bridges: A dict from BridgeId to Bridge
<ul>
<li>Key type: <strong><a href="#BridgeId">BridgeId</a></strong></li>
<li>Value type: <strong>Bridge</strong><ul>
<li class="attribute">id:  (<strong><a href="#BridgeId">BridgeId</a></strong>): The ID of the service.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">startTime:  The start time of this service (UNIX timestamp).The value must be of one of the following types: null, int.
<ul><em>Subtypes:</em>
<li><strong><a href="#null">null</a></strong></li>
<li><strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">status:  (<strong><a href="#BridgeStatus">BridgeStatus</a></strong>): The current status of the remote cluster bridge.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">clients: A dict from ClientID to Client
<ul>
<li>Key type: <strong><a href="#ClientID">ClientID</a></strong></li>
<li>Value type: <strong>Client</strong><ul>
<li class="attribute">id:  (<strong><a href="#ClientID">ClientID</a></strong>): The ID of the service. Currently this is the same as the ID of the node.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">startTime:  The start time of this service (UNIX timestamp).The value must be of one of the following types: null, int.
<ul><em>Subtypes:</em>
<li><strong><a href="#null">null</a></strong></li>
<li><strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">status:  (<strong><a href="#ClientStatus">ClientStatus</a></strong>): The current status of the client.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">clusterStatus:  (<strong><a href="#ClusterStatus">ClusterStatus</a></strong>): The current status of the whole cluster. running - At least one running server; a cluster is formed. waiting - In quorum but negotiations between servers are not over yet. down - No quorum; most likely because more beacons are needed.</li><li class="attribute">mgmt: A dict from MgmtID to Mgmt
<ul>
<li>Key type: <strong><a href="#MgmtID">MgmtID</a></strong></li>
<li>Value type: <strong>Mgmt</strong><ul>
<li class="attribute">active:  (<strong><a href="#bool">bool</a></strong>): If the instance is currently active. For a given cluster one mgmt instance will be active at any given time.</li><li class="attribute">id:  (<strong><a href="#MgmtID">MgmtID</a></strong>): The ID of the service.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">prio:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">startTime:  The start time of this service (UNIX timestamp).The value must be of one of the following types: null, int.
<ul><em>Subtypes:</em>
<li><strong><a href="#null">null</a></strong></li>
<li><strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">status:  (<strong><a href="#ClientStatus">ClientStatus</a></strong>): The current status of the mgmt instance.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">servers: A dict from ServerID to Server
<ul>
<li>Key type: <strong><a href="#ServerID">ServerID</a></strong></li>
<li>Value type: <strong>Server</strong><ul>
<li class="attribute">id:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the service. Currently this is the same as the ID of the node.</li><li class="attribute">missingDisks:  The cluster will remain down until these disks are seen again. This happens in the case of simultaneous failure of the whole cluster (power failure); the servers keep track of where the most recent configuration and data was stored.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">pendingDisks:  Similar to missingDisks, these are the disks that are ready and waiting for the missing ones.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">startTime:  The start time of this service (UNIX timestamp).The value must be of one of the following types: null, int.
<ul><em>Subtypes:</em>
<li><strong><a href="#null">null</a></strong></li>
<li><strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">status:  (<strong><a href="#ServerStatus">ServerStatus</a></strong>): down - There is no storpool_server daemon running or it is still recovering its drives from a crashed state. waiting - storpool_server is running but waiting for some disks to appear to prevent split-brain situations. booting - No missing disks; the server is in the process of joining the cluster ...</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="ServersListBlocked">List all blocked StorPool servers (<strong>ServersListBlocked</strong>)</h3>
<p>List the currently active StorPool servers even before the cluster has become
	operational, along with information about any missing disks that the cluster
	is waiting for.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ServersListBlocked HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ServersListBlocked</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "bridges": {
      "<var>BridgeId</var>": {
        "id": <var>BridgeId</var>,
        "nodeId": <var>NodeID</var>,
        "startTime": Either(<var>null</var>, <var>int</var>),
        "status": <var>BridgeStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "clients": {
      "<var>ClientID</var>": {
        "id": <var>ClientID</var>,
        "nodeId": <var>NodeID</var>,
        "startTime": Either(<var>null</var>, <var>int</var>),
        "status": <var>ClientStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "clusterStatus": <var>ClusterStatus</var>,
    "mgmt": {
      "<var>MgmtID</var>": {
        "active": <var>bool</var>,
        "id": <var>MgmtID</var>,
        "nodeId": <var>NodeID</var>,
        "prio": <var>int</var> <span class="opt">/* Internal */</span>,
        "startTime": Either(<var>null</var>, <var>int</var>),
        "status": <var>ClientStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "servers": {
      "<var>ServerID</var>": {
        "id": <var>ServerID</var>,
        "missingDisks": [<var>DiskID</var>, ...],
        "nodeId": <var>NodeID</var>,
        "pendingDisks": [<var>DiskID</var>, ...],
        "startTime": Either(<var>null</var>, <var>int</var>),
        "status": <var>ServerStatus</var>,
        "version": <var>string</var>
      }, ...
    }
  }
}
</code></pre></li>
<li>Response Data:
<strong>ClusterStatus</strong><ul>
<li class="attribute">bridges: A dict from BridgeId to Bridge
<ul>
<li>Key type: <strong><a href="#BridgeId">BridgeId</a></strong></li>
<li>Value type: <strong>Bridge</strong><ul>
<li class="attribute">id:  (<strong><a href="#BridgeId">BridgeId</a></strong>): The ID of the service.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">startTime:  The start time of this service (UNIX timestamp).The value must be of one of the following types: null, int.
<ul><em>Subtypes:</em>
<li><strong><a href="#null">null</a></strong></li>
<li><strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">status:  (<strong><a href="#BridgeStatus">BridgeStatus</a></strong>): The current status of the remote cluster bridge.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">clients: A dict from ClientID to Client
<ul>
<li>Key type: <strong><a href="#ClientID">ClientID</a></strong></li>
<li>Value type: <strong>Client</strong><ul>
<li class="attribute">id:  (<strong><a href="#ClientID">ClientID</a></strong>): The ID of the service. Currently this is the same as the ID of the node.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">startTime:  The start time of this service (UNIX timestamp).The value must be of one of the following types: null, int.
<ul><em>Subtypes:</em>
<li><strong><a href="#null">null</a></strong></li>
<li><strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">status:  (<strong><a href="#ClientStatus">ClientStatus</a></strong>): The current status of the client.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">clusterStatus:  (<strong><a href="#ClusterStatus">ClusterStatus</a></strong>): The current status of the whole cluster. running - At least one running server; a cluster is formed. waiting - In quorum but negotiations between servers are not over yet. down - No quorum; most likely because more beacons are needed.</li><li class="attribute">mgmt: A dict from MgmtID to Mgmt
<ul>
<li>Key type: <strong><a href="#MgmtID">MgmtID</a></strong></li>
<li>Value type: <strong>Mgmt</strong><ul>
<li class="attribute">active:  (<strong><a href="#bool">bool</a></strong>): If the instance is currently active. For a given cluster one mgmt instance will be active at any given time.</li><li class="attribute">id:  (<strong><a href="#MgmtID">MgmtID</a></strong>): The ID of the service.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">prio:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">startTime:  The start time of this service (UNIX timestamp).The value must be of one of the following types: null, int.
<ul><em>Subtypes:</em>
<li><strong><a href="#null">null</a></strong></li>
<li><strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">status:  (<strong><a href="#ClientStatus">ClientStatus</a></strong>): The current status of the mgmt instance.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">servers: A dict from ServerID to Server
<ul>
<li>Key type: <strong><a href="#ServerID">ServerID</a></strong></li>
<li>Value type: <strong>Server</strong><ul>
<li class="attribute">id:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the service. Currently this is the same as the ID of the node.</li><li class="attribute">missingDisks:  The cluster will remain down until these disks are seen again. This happens in the case of simultaneous failure of the whole cluster (power failure); the servers keep track of where the most recent configuration and data was stored.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">pendingDisks:  Similar to missingDisks, these are the disks that are ready and waiting for the missing ones.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">startTime:  The start time of this service (UNIX timestamp).The value must be of one of the following types: null, int.
<ul><em>Subtypes:</em>
<li><strong><a href="#null">null</a></strong></li>
<li><strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">status:  (<strong><a href="#ServerStatus">ServerStatus</a></strong>): down - There is no storpool_server daemon running or it is still recovering its drives from a crashed state. waiting - storpool_server is running but waiting for some disks to appear to prevent split-brain situations. booting - No missing disks; the server is in the process of joining the cluster ...</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Servers">Servers</h2>
<p></p>
<h3 id="ServerDisksList">List all disks on a server (<strong>ServerDisksList</strong>)</h3>
<p>Return detailed information about each disk on the given server.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ServerDisksList/{serverId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ServerDisksList/{serverId}</em></li>
<li>Arguments: 
<ul>
<li>serverId - <strong>ServerID</strong>: <em>integer, 1 &lt;= value &lt;= 32767</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>DiskID</var>": Either({
      "agAllocated": <var>int</var> <span class="opt">/* Internal */</span>,
      "agCount": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFree": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFreeing": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFull": <var>int</var> <span class="opt">/* Internal */</span>,
      "agMaxSizeFull": <var>int</var> <span class="opt">/* Internal */</span>,
      "agMaxSizePartial": <var>int</var> <span class="opt">/* Internal */</span>,
      "agPartial": <var>int</var> <span class="opt">/* Internal */</span>,
      "aggregateScore": {
        "entries": <var>int</var>,
        "space": <var>int</var>,
        "total": <var>int</var>
      } <span class="opt">/* Internal */</span>,
      "description": <var>DiskDescritpion</var>,
      "device": <var>string</var>,
      "empty": <var>bool</var>,
      "entriesAllocated": <var>int</var>,
      "entriesCount": <var>int</var>,
      "entriesFree": <var>int</var>,
      "generationLeft": <var>-1</var>,
      "id": <var>DiskID</var>,
      "isWbc": <var>bool</var>,
      "journaled": <var>bool</var>,
      "lastScrubCompleted": <var>int</var>,
      "model": <var>string</var>,
      "noFlush": <var>bool</var>,
      "noFua": <var>bool</var>,
      "noTrim": <var>bool</var>,
      "objectsAllocated": <var>int</var>,
      "objectsCount": <var>int</var>,
      "objectsFree": <var>int</var>,
      "objectsOnDiskSize": <var>long</var>,
      "scrubbedBytes": <var>int</var>,
      "scrubbingBW": <var>int</var>,
      "scrubbingFinishAfter": <var>int</var>,
      "scrubbingPaused": <var>bool</var>,
      "scrubbingPausedFor": <var>int</var>,
      "scrubbingStartedBefore": <var>int</var>,
      "sectorsCount": <var>long</var>,
      "serial": <var>string</var>,
      "serverId": <var>ServerID</var>,
      "softEject": <var>DiskSoftEjectStatus</var>,
      "ssd": <var>bool</var>,
      "wbc": Either(<var>null</var>, {
        "maxPages": <var>int</var>,
        "pages": <var>int</var>,
        "pagesPending": <var>int</var>
      }) <span class="opt">/* Internal */</span>
    }, {
      "description": <var>DiskDescritpion</var>,
      "generationLeft": <var>long</var>,
      "id": <var>DiskID</var>,
      "model": <var>string</var>,
      "serial": <var>string</var>,
      "serverId": <var>ServerID</var>,
      "softEject": <var>DiskSoftEjectStatus</var>,
      "ssd": <var>bool</var>
    }), ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from DiskID to Either(UpDiskSummary, DownDiskSummary)
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: The value must be of one of the following types: UpDiskSummary, DownDiskSummary.
<ul><em>Subtypes:</em>
<li><strong>UpDiskSummary</strong><ul>
<li class="attribute">agAllocated:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agCount:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFree:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFreeing:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizeFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizePartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agPartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">aggregateScore:  (<span class="opt">Internal</span> <strong><a href="#DiskAggregateScores">DiskAggregateScores</a></strong>)</li><li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">device:  (<strong><a href="#string">string</a></strong>): The name of the physical disk device on the server.</li><li class="attribute">empty:  (<strong><a href="#bool">bool</a></strong>): True if no volumes or snapshots are on this disk.</li><li class="attribute">entriesAllocated:  (<strong><a href="#int">int</a></strong>): Used entries of the disk.</li><li class="attribute">entriesCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of entries that can exists on the disk.</li><li class="attribute">entriesFree:  (<strong><a href="#int">int</a></strong>): The remaining number of entries that can be stored on the disk.</li><li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk. It is set when the disk is formatted to work with StorPool.</li><li class="attribute">isWbc:  (<strong><a href="#bool">bool</a></strong>): Whether write-back cache is enabled for this device.</li><li class="attribute">journaled:  (<strong><a href="#bool">bool</a></strong>): Whether StorPool journaling is enabled for this device.</li><li class="attribute">lastScrubCompleted:  (<strong><a href="#int">int</a></strong>): Unix time in seconds when last scrubbing job was completed.</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>): The drive&apos;s model.</li><li class="attribute">noFlush:  (<strong><a href="#bool">bool</a></strong>): Whether write-back cache flushing is disabled for this device.</li><li class="attribute">noFua:  (<strong><a href="#bool">bool</a></strong>): Whether to issue FUA writes to this device.</li><li class="attribute">noTrim:  (<strong><a href="#bool">bool</a></strong>): Whether trim-below is disabled for this device.</li><li class="attribute">objectsAllocated:  (<strong><a href="#int">int</a></strong>): Used objects of the disk.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">objectsFree:  (<strong><a href="#int">int</a></strong>): The remaining number of objects that can be stored on the disk.</li><li class="attribute">objectsOnDiskSize:  (<strong><a href="#long">long</a></strong>): Total size occupied by objects. In essence, this is the estimated disk usage by StorPool.</li><li class="attribute">scrubbedBytes:  (<strong><a href="#int">int</a></strong>): For current scrubbing job run.</li><li class="attribute">scrubbingBW:  (<strong><a href="#int">int</a></strong>): Estimate of the disk BS used for scrubbing B/s.</li><li class="attribute">scrubbingFinishAfter:  (<strong><a href="#int">int</a></strong>): Extimate of when the scrubbing job is expected to finish based on scrubbingBW and current disk usage.</li><li class="attribute">scrubbingPaused:  (<strong><a href="#bool">bool</a></strong>): Is scrubbing currently paused</li><li class="attribute">scrubbingPausedFor:  (<strong><a href="#int">int</a></strong>): How many seconds has the current scrubbing job been paused.</li><li class="attribute">scrubbingStartedBefore:  (<strong><a href="#int">int</a></strong>): In seconds.</li><li class="attribute">sectorsCount:  (<strong><a href="#long">long</a></strong>): The amount of 512-byte sectors on the disk.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>): The drive&apos;s serial.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk is currently on. In case the disk is currently down, the last known server ID is reported.</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li><li class="attribute">wbc:  (<span class="opt">Internal</span> <strong><a href="#Either(null, DiskWbcStats)">Either(null, DiskWbcStats)</a></strong>)</li></ul>
</li>
<li><strong>DownDiskSummary</strong><ul>
<li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk. It is set when the disk is formatted to work with StorPool.</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>): The drive&apos;s model.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>): The drive&apos;s serial.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk is currently on. In case the disk is currently down, the last known server ID is reported.</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="ServerDiskDescribe">Describe a disk on a server (<strong>ServerDiskDescribe</strong>)</h3>
<p>Return detailed information about a disk on the given server and the
	objects on it.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ServerDiskDescribe/{serverId}/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ServerDiskDescribe/{serverId}/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
<li>serverId - <strong>ServerID</strong>: <em>integer, 1 &lt;= value &lt;= 32767</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "agAllocated": <var>int</var> <span class="opt">/* Internal */</span>,
    "agCount": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFree": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFreeing": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizeFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizePartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "agPartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "aggregateScore": {
      "entries": <var>int</var>,
      "space": <var>int</var>,
      "total": <var>int</var>
    } <span class="opt">/* Internal */</span>,
    "description": <var>DiskDescritpion</var>,
    "device": <var>string</var>,
    "empty": <var>bool</var>,
    "entriesAllocated": <var>int</var>,
    "entriesCount": <var>int</var>,
    "entriesFree": <var>int</var>,
    "generationLeft": <var>-1</var>,
    "id": <var>DiskID</var>,
    "isWbc": <var>bool</var>,
    "journaled": <var>bool</var>,
    "lastScrubCompleted": <var>int</var>,
    "model": <var>string</var>,
    "noFlush": <var>bool</var>,
    "noFua": <var>bool</var>,
    "noTrim": <var>bool</var>,
    "objects": {
      "<var>int</var>": {
        "generation": <var>long</var>,
        "objectId": <var>int</var> <span class="opt">/* Internal */</span>,
        "onDiskSize": <var>int</var>,
        "parentVolume": <var>string</var>,
        "state": <var>ObjectState</var>,
        "storedSize": <var>int</var>,
        "version": <var>long</var>,
        "volume": <var>string</var>,
        "volumeId": <var>long</var> <span class="opt">/* Internal */</span>
      }, ...
    },
    "objectsAllocated": <var>int</var>,
    "objectsCount": <var>int</var>,
    "objectsFree": <var>int</var>,
    "objectsOnDiskSize": <var>long</var>,
    "scrubbedBytes": <var>int</var>,
    "scrubbingBW": <var>int</var>,
    "scrubbingFinishAfter": <var>int</var>,
    "scrubbingPaused": <var>bool</var>,
    "scrubbingPausedFor": <var>int</var>,
    "scrubbingStartedBefore": <var>int</var>,
    "sectorsCount": <var>long</var>,
    "serial": <var>string</var>,
    "serverId": <var>ServerID</var>,
    "softEject": <var>DiskSoftEjectStatus</var>,
    "ssd": <var>bool</var>,
    "wbc": Either(<var>null</var>, {
      "maxPages": <var>int</var>,
      "pages": <var>int</var>,
      "pagesPending": <var>int</var>
    }) <span class="opt">/* Internal */</span>
  }
}
</code></pre></li>
<li>Response Data:
<strong>Disk</strong><ul>
<li class="attribute">agAllocated:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agCount:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFree:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFreeing:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizeFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizePartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agPartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">aggregateScore:  (<span class="opt">Internal</span> <strong><a href="#DiskAggregateScores">DiskAggregateScores</a></strong>)</li><li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">device:  (<strong><a href="#string">string</a></strong>): The name of the physical disk device on the server.</li><li class="attribute">empty:  (<strong><a href="#bool">bool</a></strong>): True if no volumes or snapshots are on this disk.</li><li class="attribute">entriesAllocated:  (<strong><a href="#int">int</a></strong>): Used entries of the disk.</li><li class="attribute">entriesCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of entries that can exists on the disk.</li><li class="attribute">entriesFree:  (<strong><a href="#int">int</a></strong>): The remaining number of entries that can be stored on the disk.</li><li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk. It is set when the disk is formatted to work with StorPool.</li><li class="attribute">isWbc:  (<strong><a href="#bool">bool</a></strong>): Whether write-back cache is enabled for this device.</li><li class="attribute">journaled:  (<strong><a href="#bool">bool</a></strong>): Whether StorPool journaling is enabled for this device.</li><li class="attribute">lastScrubCompleted:  (<strong><a href="#int">int</a></strong>): Unix time in seconds when last scrubbing job was completed.</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>): The drive&apos;s model.</li><li class="attribute">noFlush:  (<strong><a href="#bool">bool</a></strong>): Whether write-back cache flushing is disabled for this device.</li><li class="attribute">noFua:  (<strong><a href="#bool">bool</a></strong>): Whether to issue FUA writes to this device.</li><li class="attribute">noTrim:  (<strong><a href="#bool">bool</a></strong>): Whether trim-below is disabled for this device.</li><li class="attribute">objects:  Detailed information about each object on the disk.A dict from int to DiskObject
<ul>
<li>Key type: <strong><a href="#int">int</a></strong></li>
<li>Value type: <strong>DiskObject</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The generation when the last write to this object occurred.</li><li class="attribute">objectId:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">onDiskSize:  (<strong><a href="#int">int</a></strong>): The space allocated on the disk for the object. This can go up to 32MB.</li><li class="attribute">parentVolume:  (<strong><a href="#string">string</a></strong>): The name of the parent snapshot.</li><li class="attribute">state:  (<strong><a href="#ObjectState">ObjectState</a></strong>)</li><li class="attribute">storedSize:  (<strong><a href="#int">int</a></strong>): The size of the actual data in that object (&lt;= onDiskSize).</li><li class="attribute">version:  (<strong><a href="#long">long</a></strong>): With each write the version is increased.</li><li class="attribute">volume:  (<strong><a href="#string">string</a></strong>): The name of the volume for which the object contains data.</li><li class="attribute">volumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li></ul>
</li>
</ul>
</li><li class="attribute">objectsAllocated:  (<strong><a href="#int">int</a></strong>): Used objects of the disk.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">objectsFree:  (<strong><a href="#int">int</a></strong>): The remaining number of objects that can be stored on the disk.</li><li class="attribute">objectsOnDiskSize:  (<strong><a href="#long">long</a></strong>): Total size occupied by objects. In essence, this is the estimated disk usage by StorPool.</li><li class="attribute">scrubbedBytes:  (<strong><a href="#int">int</a></strong>): For current scrubbing job run.</li><li class="attribute">scrubbingBW:  (<strong><a href="#int">int</a></strong>): Estimate of the disk BS used for scrubbing B/s.</li><li class="attribute">scrubbingFinishAfter:  (<strong><a href="#int">int</a></strong>): Extimate of when the scrubbing job is expected to finish based on scrubbingBW and current disk usage.</li><li class="attribute">scrubbingPaused:  (<strong><a href="#bool">bool</a></strong>): Is scrubbing currently paused</li><li class="attribute">scrubbingPausedFor:  (<strong><a href="#int">int</a></strong>): How many seconds has the current scrubbing job been paused.</li><li class="attribute">scrubbingStartedBefore:  (<strong><a href="#int">int</a></strong>): In seconds.</li><li class="attribute">sectorsCount:  (<strong><a href="#long">long</a></strong>): The amount of 512-byte sectors on the disk.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>): The drive&apos;s serial.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk is currently on. In case the disk is currently down, the last known server ID is reported.</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li><li class="attribute">wbc:  (<span class="opt">Internal</span> <strong><a href="#Either(null, DiskWbcStats)">Either(null, DiskWbcStats)</a></strong>)</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Clients">Clients</h2>
<p></p>
<h3 id="ClientsConfigDump">Get the current status of all the clients (<strong>ClientsConfigDump</strong>)</h3>
<p>Return the status of each client including its current generation and
	generation update status.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ClientsConfigDump HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ClientsConfigDump</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "clientGeneration": <var>long</var>,
    "configStatus": <var>client status</var>,
    "delay": <var>int</var>,
    "generation": <var>long</var>,
    "id": <var>ClientID</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>ClientConfigStatus</strong><ul>
<li class="attribute">clientGeneration:  (<strong><a href="#long">long</a></strong>): The generation of the specific client.</li><li class="attribute">configStatus:  (<strong><a href="#client status">client status</a></strong>): Whether there is an update of the configuration in progress.</li><li class="attribute">delay:  (<strong><a href="#int">int</a></strong>): The time it took for the client generation to reach the cluster generation. Only applicable to ClientConfigWait. Always 0 in ClientsConfigDump.</li><li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">id:  (<strong><a href="#ClientID">ClientID</a></strong>)</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="ClientConfigWait">Wait until a client updates to the current configuration (<strong>ClientConfigWait</strong>)</h3>
<p>Return the same JSON as ClientsConfigDump but block until the client
	has updated its configuration information to the current generation at
	the time of the request.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ClientConfigWait/{clientId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ClientConfigWait/{clientId}</em></li>
<li>Arguments: 
<ul>
<li>clientId - <strong>ClientID</strong>: <em>integer, 1 &lt;= value &lt;= 4096</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "clientGeneration": <var>long</var>,
    "configStatus": <var>client status</var>,
    "delay": <var>int</var>,
    "generation": <var>long</var>,
    "id": <var>ClientID</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>ClientConfigStatus</strong><ul>
<li class="attribute">clientGeneration:  (<strong><a href="#long">long</a></strong>): The generation of the specific client.</li><li class="attribute">configStatus:  (<strong><a href="#client status">client status</a></strong>): Whether there is an update of the configuration in progress.</li><li class="attribute">delay:  (<strong><a href="#int">int</a></strong>): The time it took for the client generation to reach the cluster generation. Only applicable to ClientConfigWait. Always 0 in ClientsConfigDump.</li><li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">id:  (<strong><a href="#ClientID">ClientID</a></strong>)</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="ClientActiveRequests">List all the active requests on a client (<strong>ClientActiveRequests</strong>)</h3>
<p>List detailed information about the requests being currently processed on
	the given client.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ClientActiveRequests/{clientId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ClientActiveRequests/{clientId}</em></li>
<li>Arguments: 
<ul>
<li>clientId - <strong>ClientID</strong>: <em>integer, 1 &lt;= value &lt;= 4096</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "clientId": <var>ClientID</var>,
    "requests": [{
      "address": <var>long</var>,
      "drOp": <var>string</var> <span class="opt">/* Internal */</span>,
      "msecActive": <var>int</var>,
      "op": <var>RequestOp</var>,
      "prevState": <var>string</var> <span class="opt">/* Internal */</span>,
      "requestId": <var>string</var>,
      "requestIdx": <var>int</var>,
      "size": <var>int</var>,
      "state": <var>string</var> <span class="opt">/* Internal */</span>,
      "volume": Either(<var>VolumeName</var>, <var>SnapshotName</var>)
    }, ...]
  }
}
</code></pre></li>
<li>Response Data:
<strong>ClientActiveRequests</strong><ul>
<li class="attribute">clientId:  (<strong><a href="#ClientID">ClientID</a></strong>)</li><li class="attribute">requests:  A detailed listing of all the requests associated with the given client.<ul>Element type: <strong>ActiveRequestDesc</strong><ul>
<li class="attribute">address:  (<strong><a href="#long">long</a></strong>): The offset in bytes within the logical volume.</li><li class="attribute">drOp:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">msecActive:  (<strong><a href="#int">int</a></strong>): Time in microseconds since the request was submitted.</li><li class="attribute">op:  (<strong><a href="#RequestOp">RequestOp</a></strong>): The type of the requested operation; one of read, write, system, merge, entries flush, #bad_state, #bad_drOp</li><li class="attribute">prevState:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">requestId:  (<strong><a href="#string">string</a></strong>): A unique request ID that may be matched between clients and disks.</li><li class="attribute">requestIdx:  (<strong><a href="#int">int</a></strong>): A temporary local request identifier for this request on this client or disk.</li><li class="attribute">size:  (<strong><a href="#int">int</a></strong>): The size of the request in bytes.</li><li class="attribute">state:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">volume: The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li></ul>

</li></ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Disks">Disks</h2>
<p></p>
<h3 id="DisksList">List all disks (<strong>DisksList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/DisksList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/DisksList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>DiskID</var>": Either({
      "agAllocated": <var>int</var> <span class="opt">/* Internal */</span>,
      "agCount": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFree": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFreeing": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFull": <var>int</var> <span class="opt">/* Internal */</span>,
      "agMaxSizeFull": <var>int</var> <span class="opt">/* Internal */</span>,
      "agMaxSizePartial": <var>int</var> <span class="opt">/* Internal */</span>,
      "agPartial": <var>int</var> <span class="opt">/* Internal */</span>,
      "aggregateScore": {
        "entries": <var>int</var>,
        "space": <var>int</var>,
        "total": <var>int</var>
      } <span class="opt">/* Internal */</span>,
      "description": <var>DiskDescritpion</var>,
      "device": <var>string</var>,
      "empty": <var>bool</var>,
      "entriesAllocated": <var>int</var>,
      "entriesCount": <var>int</var>,
      "entriesFree": <var>int</var>,
      "generationLeft": <var>-1</var>,
      "id": <var>DiskID</var>,
      "isWbc": <var>bool</var>,
      "journaled": <var>bool</var>,
      "lastScrubCompleted": <var>int</var>,
      "model": <var>string</var>,
      "noFlush": <var>bool</var>,
      "noFua": <var>bool</var>,
      "noTrim": <var>bool</var>,
      "objectsAllocated": <var>int</var>,
      "objectsCount": <var>int</var>,
      "objectsFree": <var>int</var>,
      "objectsOnDiskSize": <var>long</var>,
      "scrubbedBytes": <var>int</var>,
      "scrubbingBW": <var>int</var>,
      "scrubbingFinishAfter": <var>int</var>,
      "scrubbingPaused": <var>bool</var>,
      "scrubbingPausedFor": <var>int</var>,
      "scrubbingStartedBefore": <var>int</var>,
      "sectorsCount": <var>long</var>,
      "serial": <var>string</var>,
      "serverId": <var>ServerID</var>,
      "softEject": <var>DiskSoftEjectStatus</var>,
      "ssd": <var>bool</var>,
      "wbc": Either(<var>null</var>, {
        "maxPages": <var>int</var>,
        "pages": <var>int</var>,
        "pagesPending": <var>int</var>
      }) <span class="opt">/* Internal */</span>
    }, {
      "description": <var>DiskDescritpion</var>,
      "generationLeft": <var>long</var>,
      "id": <var>DiskID</var>,
      "model": <var>string</var>,
      "serial": <var>string</var>,
      "serverId": <var>ServerID</var>,
      "softEject": <var>DiskSoftEjectStatus</var>,
      "ssd": <var>bool</var>
    }), ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from DiskID to Either(UpDiskSummary, DownDiskSummary)
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: The value must be of one of the following types: UpDiskSummary, DownDiskSummary.
<ul><em>Subtypes:</em>
<li><strong>UpDiskSummary</strong><ul>
<li class="attribute">agAllocated:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agCount:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFree:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFreeing:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizeFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizePartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agPartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">aggregateScore:  (<span class="opt">Internal</span> <strong><a href="#DiskAggregateScores">DiskAggregateScores</a></strong>)</li><li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">device:  (<strong><a href="#string">string</a></strong>): The name of the physical disk device on the server.</li><li class="attribute">empty:  (<strong><a href="#bool">bool</a></strong>): True if no volumes or snapshots are on this disk.</li><li class="attribute">entriesAllocated:  (<strong><a href="#int">int</a></strong>): Used entries of the disk.</li><li class="attribute">entriesCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of entries that can exists on the disk.</li><li class="attribute">entriesFree:  (<strong><a href="#int">int</a></strong>): The remaining number of entries that can be stored on the disk.</li><li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk. It is set when the disk is formatted to work with StorPool.</li><li class="attribute">isWbc:  (<strong><a href="#bool">bool</a></strong>): Whether write-back cache is enabled for this device.</li><li class="attribute">journaled:  (<strong><a href="#bool">bool</a></strong>): Whether StorPool journaling is enabled for this device.</li><li class="attribute">lastScrubCompleted:  (<strong><a href="#int">int</a></strong>): Unix time in seconds when last scrubbing job was completed.</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>): The drive&apos;s model.</li><li class="attribute">noFlush:  (<strong><a href="#bool">bool</a></strong>): Whether write-back cache flushing is disabled for this device.</li><li class="attribute">noFua:  (<strong><a href="#bool">bool</a></strong>): Whether to issue FUA writes to this device.</li><li class="attribute">noTrim:  (<strong><a href="#bool">bool</a></strong>): Whether trim-below is disabled for this device.</li><li class="attribute">objectsAllocated:  (<strong><a href="#int">int</a></strong>): Used objects of the disk.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">objectsFree:  (<strong><a href="#int">int</a></strong>): The remaining number of objects that can be stored on the disk.</li><li class="attribute">objectsOnDiskSize:  (<strong><a href="#long">long</a></strong>): Total size occupied by objects. In essence, this is the estimated disk usage by StorPool.</li><li class="attribute">scrubbedBytes:  (<strong><a href="#int">int</a></strong>): For current scrubbing job run.</li><li class="attribute">scrubbingBW:  (<strong><a href="#int">int</a></strong>): Estimate of the disk BS used for scrubbing B/s.</li><li class="attribute">scrubbingFinishAfter:  (<strong><a href="#int">int</a></strong>): Extimate of when the scrubbing job is expected to finish based on scrubbingBW and current disk usage.</li><li class="attribute">scrubbingPaused:  (<strong><a href="#bool">bool</a></strong>): Is scrubbing currently paused</li><li class="attribute">scrubbingPausedFor:  (<strong><a href="#int">int</a></strong>): How many seconds has the current scrubbing job been paused.</li><li class="attribute">scrubbingStartedBefore:  (<strong><a href="#int">int</a></strong>): In seconds.</li><li class="attribute">sectorsCount:  (<strong><a href="#long">long</a></strong>): The amount of 512-byte sectors on the disk.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>): The drive&apos;s serial.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk is currently on. In case the disk is currently down, the last known server ID is reported.</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li><li class="attribute">wbc:  (<span class="opt">Internal</span> <strong><a href="#Either(null, DiskWbcStats)">Either(null, DiskWbcStats)</a></strong>)</li></ul>
</li>
<li><strong>DownDiskSummary</strong><ul>
<li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk. It is set when the disk is formatted to work with StorPool.</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>): The drive&apos;s model.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>): The drive&apos;s serial.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk is currently on. In case the disk is currently down, the last known server ID is reported.</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskDescribe">Describe a disk (<strong>DiskDescribe</strong>)</h3>
<p>List all disks including detailed information about the objects on each disk.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/DiskDescribe/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/DiskDescribe/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "agAllocated": <var>int</var> <span class="opt">/* Internal */</span>,
    "agCount": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFree": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFreeing": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizeFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizePartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "agPartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "aggregateScore": {
      "entries": <var>int</var>,
      "space": <var>int</var>,
      "total": <var>int</var>
    } <span class="opt">/* Internal */</span>,
    "description": <var>DiskDescritpion</var>,
    "device": <var>string</var>,
    "empty": <var>bool</var>,
    "entriesAllocated": <var>int</var>,
    "entriesCount": <var>int</var>,
    "entriesFree": <var>int</var>,
    "generationLeft": <var>-1</var>,
    "id": <var>DiskID</var>,
    "isWbc": <var>bool</var>,
    "journaled": <var>bool</var>,
    "lastScrubCompleted": <var>int</var>,
    "model": <var>string</var>,
    "noFlush": <var>bool</var>,
    "noFua": <var>bool</var>,
    "noTrim": <var>bool</var>,
    "objects": {
      "<var>int</var>": {
        "generation": <var>long</var>,
        "objectId": <var>int</var> <span class="opt">/* Internal */</span>,
        "onDiskSize": <var>int</var>,
        "parentVolume": <var>string</var>,
        "state": <var>ObjectState</var>,
        "storedSize": <var>int</var>,
        "version": <var>long</var>,
        "volume": <var>string</var>,
        "volumeId": <var>long</var> <span class="opt">/* Internal */</span>
      }, ...
    },
    "objectsAllocated": <var>int</var>,
    "objectsCount": <var>int</var>,
    "objectsFree": <var>int</var>,
    "objectsOnDiskSize": <var>long</var>,
    "scrubbedBytes": <var>int</var>,
    "scrubbingBW": <var>int</var>,
    "scrubbingFinishAfter": <var>int</var>,
    "scrubbingPaused": <var>bool</var>,
    "scrubbingPausedFor": <var>int</var>,
    "scrubbingStartedBefore": <var>int</var>,
    "sectorsCount": <var>long</var>,
    "serial": <var>string</var>,
    "serverId": <var>ServerID</var>,
    "softEject": <var>DiskSoftEjectStatus</var>,
    "ssd": <var>bool</var>,
    "wbc": Either(<var>null</var>, {
      "maxPages": <var>int</var>,
      "pages": <var>int</var>,
      "pagesPending": <var>int</var>
    }) <span class="opt">/* Internal */</span>
  }
}
</code></pre></li>
<li>Response Data:
<strong>Disk</strong><ul>
<li class="attribute">agAllocated:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agCount:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFree:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFreeing:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizeFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizePartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agPartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">aggregateScore:  (<span class="opt">Internal</span> <strong><a href="#DiskAggregateScores">DiskAggregateScores</a></strong>)</li><li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">device:  (<strong><a href="#string">string</a></strong>): The name of the physical disk device on the server.</li><li class="attribute">empty:  (<strong><a href="#bool">bool</a></strong>): True if no volumes or snapshots are on this disk.</li><li class="attribute">entriesAllocated:  (<strong><a href="#int">int</a></strong>): Used entries of the disk.</li><li class="attribute">entriesCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of entries that can exists on the disk.</li><li class="attribute">entriesFree:  (<strong><a href="#int">int</a></strong>): The remaining number of entries that can be stored on the disk.</li><li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk. It is set when the disk is formatted to work with StorPool.</li><li class="attribute">isWbc:  (<strong><a href="#bool">bool</a></strong>): Whether write-back cache is enabled for this device.</li><li class="attribute">journaled:  (<strong><a href="#bool">bool</a></strong>): Whether StorPool journaling is enabled for this device.</li><li class="attribute">lastScrubCompleted:  (<strong><a href="#int">int</a></strong>): Unix time in seconds when last scrubbing job was completed.</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>): The drive&apos;s model.</li><li class="attribute">noFlush:  (<strong><a href="#bool">bool</a></strong>): Whether write-back cache flushing is disabled for this device.</li><li class="attribute">noFua:  (<strong><a href="#bool">bool</a></strong>): Whether to issue FUA writes to this device.</li><li class="attribute">noTrim:  (<strong><a href="#bool">bool</a></strong>): Whether trim-below is disabled for this device.</li><li class="attribute">objects:  Detailed information about each object on the disk.A dict from int to DiskObject
<ul>
<li>Key type: <strong><a href="#int">int</a></strong></li>
<li>Value type: <strong>DiskObject</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The generation when the last write to this object occurred.</li><li class="attribute">objectId:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">onDiskSize:  (<strong><a href="#int">int</a></strong>): The space allocated on the disk for the object. This can go up to 32MB.</li><li class="attribute">parentVolume:  (<strong><a href="#string">string</a></strong>): The name of the parent snapshot.</li><li class="attribute">state:  (<strong><a href="#ObjectState">ObjectState</a></strong>)</li><li class="attribute">storedSize:  (<strong><a href="#int">int</a></strong>): The size of the actual data in that object (&lt;= onDiskSize).</li><li class="attribute">version:  (<strong><a href="#long">long</a></strong>): With each write the version is increased.</li><li class="attribute">volume:  (<strong><a href="#string">string</a></strong>): The name of the volume for which the object contains data.</li><li class="attribute">volumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li></ul>
</li>
</ul>
</li><li class="attribute">objectsAllocated:  (<strong><a href="#int">int</a></strong>): Used objects of the disk.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">objectsFree:  (<strong><a href="#int">int</a></strong>): The remaining number of objects that can be stored on the disk.</li><li class="attribute">objectsOnDiskSize:  (<strong><a href="#long">long</a></strong>): Total size occupied by objects. In essence, this is the estimated disk usage by StorPool.</li><li class="attribute">scrubbedBytes:  (<strong><a href="#int">int</a></strong>): For current scrubbing job run.</li><li class="attribute">scrubbingBW:  (<strong><a href="#int">int</a></strong>): Estimate of the disk BS used for scrubbing B/s.</li><li class="attribute">scrubbingFinishAfter:  (<strong><a href="#int">int</a></strong>): Extimate of when the scrubbing job is expected to finish based on scrubbingBW and current disk usage.</li><li class="attribute">scrubbingPaused:  (<strong><a href="#bool">bool</a></strong>): Is scrubbing currently paused</li><li class="attribute">scrubbingPausedFor:  (<strong><a href="#int">int</a></strong>): How many seconds has the current scrubbing job been paused.</li><li class="attribute">scrubbingStartedBefore:  (<strong><a href="#int">int</a></strong>): In seconds.</li><li class="attribute">sectorsCount:  (<strong><a href="#long">long</a></strong>): The amount of 512-byte sectors on the disk.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>): The drive&apos;s serial.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk is currently on. In case the disk is currently down, the last known server ID is reported.</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li><li class="attribute">wbc:  (<span class="opt">Internal</span> <strong><a href="#Either(null, DiskWbcStats)">Either(null, DiskWbcStats)</a></strong>)</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskGetInfo">Get disk info (<strong>DiskGetInfo</strong>)</h3>
<p>List all disks including information about the volumes stored on each disk.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/DiskGetInfo/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/DiskGetInfo/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "agAllocated": <var>int</var> <span class="opt">/* Internal */</span>,
    "agCount": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFree": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFreeing": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizeFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizePartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "agPartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "aggregateScore": {
      "entries": <var>int</var>,
      "space": <var>int</var>,
      "total": <var>int</var>
    } <span class="opt">/* Internal */</span>,
    "description": <var>DiskDescritpion</var>,
    "device": <var>string</var>,
    "empty": <var>bool</var>,
    "entriesAllocated": <var>int</var>,
    "entriesCount": <var>int</var>,
    "entriesFree": <var>int</var>,
    "generationLeft": <var>-1</var>,
    "id": <var>DiskID</var>,
    "isWbc": <var>bool</var>,
    "journaled": <var>bool</var>,
    "lastScrubCompleted": <var>int</var>,
    "model": <var>string</var>,
    "noFlush": <var>bool</var>,
    "noFua": <var>bool</var>,
    "noTrim": <var>bool</var>,
    "objectStates": {
      "<var>ObjectState</var>": <var>int</var>, ...
    },
    "objectsAllocated": <var>int</var>,
    "objectsCount": <var>int</var>,
    "objectsFree": <var>int</var>,
    "objectsOnDiskSize": <var>long</var>,
    "scrubbedBytes": <var>int</var>,
    "scrubbingBW": <var>int</var>,
    "scrubbingFinishAfter": <var>int</var>,
    "scrubbingPaused": <var>bool</var>,
    "scrubbingPausedFor": <var>int</var>,
    "scrubbingStartedBefore": <var>int</var>,
    "sectorsCount": <var>long</var>,
    "serial": <var>string</var>,
    "serverId": <var>ServerID</var>,
    "softEject": <var>DiskSoftEjectStatus</var>,
    "ssd": <var>bool</var>,
    "volumeInfos": {
      "<var>string</var>": {
        "name": <var>string</var>,
        "objectStates": {
          "<var>ObjectState</var>": <var>int</var>, ...
        },
        "objectsCount": <var>long</var>,
        "onDiskSize": <var>long</var>,
        "storedSize": <var>long</var>
      }, ...
    },
    "wbc": Either(<var>null</var>, {
      "maxPages": <var>int</var>,
      "pages": <var>int</var>,
      "pagesPending": <var>int</var>
    }) <span class="opt">/* Internal */</span>
  }
}
</code></pre></li>
<li>Response Data:
<strong>DiskInfo</strong><ul>
<li class="attribute">agAllocated:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agCount:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFree:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFreeing:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizeFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizePartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agPartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">aggregateScore:  (<span class="opt">Internal</span> <strong><a href="#DiskAggregateScores">DiskAggregateScores</a></strong>)</li><li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">device:  (<strong><a href="#string">string</a></strong>): The name of the physical disk device on the server.</li><li class="attribute">empty:  (<strong><a href="#bool">bool</a></strong>): True if no volumes or snapshots are on this disk.</li><li class="attribute">entriesAllocated:  (<strong><a href="#int">int</a></strong>): Used entries of the disk.</li><li class="attribute">entriesCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of entries that can exists on the disk.</li><li class="attribute">entriesFree:  (<strong><a href="#int">int</a></strong>): The remaining number of entries that can be stored on the disk.</li><li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk. It is set when the disk is formatted to work with StorPool.</li><li class="attribute">isWbc:  (<strong><a href="#bool">bool</a></strong>): Whether write-back cache is enabled for this device.</li><li class="attribute">journaled:  (<strong><a href="#bool">bool</a></strong>): Whether StorPool journaling is enabled for this device.</li><li class="attribute">lastScrubCompleted:  (<strong><a href="#int">int</a></strong>): Unix time in seconds when last scrubbing job was completed.</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>): The drive&apos;s model.</li><li class="attribute">noFlush:  (<strong><a href="#bool">bool</a></strong>): Whether write-back cache flushing is disabled for this device.</li><li class="attribute">noFua:  (<strong><a href="#bool">bool</a></strong>): Whether to issue FUA writes to this device.</li><li class="attribute">noTrim:  (<strong><a href="#bool">bool</a></strong>): Whether trim-below is disabled for this device.</li><li class="attribute">objectStates: A dict from ObjectState to int
<ul>
<li>Key type: <strong><a href="#ObjectState">ObjectState</a></strong></li>
<li>Value type: <strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">objectsAllocated:  (<strong><a href="#int">int</a></strong>): Used objects of the disk.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">objectsFree:  (<strong><a href="#int">int</a></strong>): The remaining number of objects that can be stored on the disk.</li><li class="attribute">objectsOnDiskSize:  (<strong><a href="#long">long</a></strong>): Total size occupied by objects. In essence, this is the estimated disk usage by StorPool.</li><li class="attribute">scrubbedBytes:  (<strong><a href="#int">int</a></strong>): For current scrubbing job run.</li><li class="attribute">scrubbingBW:  (<strong><a href="#int">int</a></strong>): Estimate of the disk BS used for scrubbing B/s.</li><li class="attribute">scrubbingFinishAfter:  (<strong><a href="#int">int</a></strong>): Extimate of when the scrubbing job is expected to finish based on scrubbingBW and current disk usage.</li><li class="attribute">scrubbingPaused:  (<strong><a href="#bool">bool</a></strong>): Is scrubbing currently paused</li><li class="attribute">scrubbingPausedFor:  (<strong><a href="#int">int</a></strong>): How many seconds has the current scrubbing job been paused.</li><li class="attribute">scrubbingStartedBefore:  (<strong><a href="#int">int</a></strong>): In seconds.</li><li class="attribute">sectorsCount:  (<strong><a href="#long">long</a></strong>): The amount of 512-byte sectors on the disk.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>): The drive&apos;s serial.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk is currently on. In case the disk is currently down, the last known server ID is reported.</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li><li class="attribute">volumeInfos:  Detailed information about the volumes that have data stored on the disk.A dict from str to DiskVolumeInfo
<ul>
<li>Key type: <strong><a href="#string">string</a></strong></li>
<li>Value type: <strong>DiskVolumeInfo</strong><ul>
<li class="attribute">name:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">objectStates:  For each state, the number of objects that are in that state. 0-undefined 1-ok 2-outdated 3-in_recovery 4-waiting_for_version 5-waiting_for_disk 6-data_not_present 7-data_lost 8-waiting_for_chain 9-wait_idleA dict from ObjectState to int
<ul>
<li>Key type: <strong><a href="#ObjectState">ObjectState</a></strong></li>
<li>Value type: <strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#long">long</a></strong>): The number of objects of the volume stored on this disk.</li><li class="attribute">onDiskSize:  (<strong><a href="#long">long</a></strong>): The space allocated on the disk for the object. This can go up to 32MB.</li><li class="attribute">storedSize:  (<strong><a href="#long">long</a></strong>): The size of the actual data in that object (&lt;= onDiskSize).</li></ul>
</li>
</ul>
</li><li class="attribute">wbc:  (<span class="opt">Internal</span> <strong><a href="#Either(null, DiskWbcStats)">Either(null, DiskWbcStats)</a></strong>)</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskEject">Eject a disk (<strong>DiskEject</strong>)</h3>
<p>Stop operations on the given disk even if it is not empty.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskEject/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskEject/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskForget">Forget a disk (<strong>DiskForget</strong>)</h3>
<p>Remove the disk from any placement groups or volumes that it is used in.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskForget/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskForget/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskIgnore">Ignore a disk (<strong>DiskIgnore</strong>)</h3>
<p>Try to boot the cluster by ignoring this disk.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskIgnore/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskIgnore/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskSoftEject">Soft-eject a disk (<strong>DiskSoftEject</strong>)</h3>
<p>Stop writes to the given disk and start relocating all the data stored on it to other disks.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskSoftEject/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskSoftEject/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskSoftEjectPause">Pause a disk&apos;s soft-eject operation (<strong>DiskSoftEjectPause</strong>)</h3>
<p>Temporarily pause the relocation tasks for the disk. This can be helpful in heavy load situations.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskSoftEjectPause/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskSoftEjectPause/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskSoftEjectCancel">Cancel a disk&apos;s soft-eject operation (<strong>DiskSoftEjectCancel</strong>)</h3>
<p>Stop the relocation tasks for the disk and mark it as usable again. After this operation data will be moved back to the disk.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskSoftEjectCancel/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskSoftEjectCancel/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskSetDescription">Set a disk&apos;s description (<strong>DiskSetDescription</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskSetDescription/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "description": <var>DiskDescritpion</var>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskSetDescription/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <strong>DiskDescUpdate</strong><ul>
<li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskActiveRequests">List all the active requests on a disk (<strong>DiskActiveRequests</strong>)</h3>
<p>List detailed information about the requests being currently processed
	on the given disk.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/DiskActiveRequests/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/DiskActiveRequests/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "diskId": <var>DiskID</var>,
    "requests": [{
      "address": <var>long</var>,
      "drOp": <var>string</var> <span class="opt">/* Internal */</span>,
      "msecActive": <var>int</var>,
      "op": <var>RequestOp</var>,
      "prevState": <var>string</var> <span class="opt">/* Internal */</span>,
      "requestId": <var>string</var>,
      "requestIdx": <var>int</var>,
      "size": <var>int</var>,
      "state": <var>string</var> <span class="opt">/* Internal */</span>,
      "volume": Either(<var>VolumeName</var>, <var>SnapshotName</var>)
    }, ...]
  }
}
</code></pre></li>
<li>Response Data:
<strong>DiskActiveRequests</strong><ul>
<li class="attribute">diskId:  (<strong><a href="#DiskID">DiskID</a></strong>)</li><li class="attribute">requests:  A detailed listing of all the requests associated with the given disk.<ul>Element type: <strong>ActiveRequestDesc</strong><ul>
<li class="attribute">address:  (<strong><a href="#long">long</a></strong>): The offset in bytes within the logical volume.</li><li class="attribute">drOp:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">msecActive:  (<strong><a href="#int">int</a></strong>): Time in microseconds since the request was submitted.</li><li class="attribute">op:  (<strong><a href="#RequestOp">RequestOp</a></strong>): The type of the requested operation; one of read, write, system, merge, entries flush, #bad_state, #bad_drOp</li><li class="attribute">prevState:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">requestId:  (<strong><a href="#string">string</a></strong>): A unique request ID that may be matched between clients and disks.</li><li class="attribute">requestIdx:  (<strong><a href="#int">int</a></strong>): A temporary local request identifier for this request on this client or disk.</li><li class="attribute">size:  (<strong><a href="#int">int</a></strong>): The size of the request in bytes.</li><li class="attribute">state:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">volume: The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li></ul>

</li></ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskScrubStart">Start scrubbing process (<strong>DiskScrubStart</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskScrubStart/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskScrubStart/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskScrubPause">Pause scrubbing process (<strong>DiskScrubPause</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskScrubPause/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskScrubPause/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskScrubContinue">Continue paused scrubbing process (<strong>DiskScrubContinue</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskScrubContinue/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskScrubContinue/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskRetrim">Retrim disk (<strong>DiskRetrim</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskRetrim/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskRetrim/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Volumes">Volumes</h2>
<p></p>
<h3 id="VolumesList">List all volumes (<strong>VolumesList</strong>)</h3>
<p>Return configuration information about all the volumes.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumesList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumesList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>VolumeSummary</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of this volume.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumesGetStatus">Get volume and snapshot status (<strong>VolumesGetStatus</strong>)</h3>
<p>Return the status of each volume and snapshot.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumesGetStatus HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumesGetStatus</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "Either(<var>VolumeName</var>, <var>SnapshotName</var>)": {
      "balancerBlocked": <var>bool</var>,
      "decreasedRedundancy": <var>bool</var>,
      "downBytes": <var>int</var>,
      "downDrives": [<var>DiskID</var>, ...],
      "migrating": <var>bool</var>,
      "missingDrives": [<var>DiskID</var>, ...],
      "missingTargetDrives": [<var>DiskID</var>, ...],
      "name": Either(<var>VolumeName</var>, <var>SnapshotName</var>),
      "onDiskSize": <var>int</var>,
      "replication": <var>Replication</var>,
      "size": <var>Size</var>,
      "snapshot": <var>bool</var>,
      "softEjectingDrives": [<var>DiskID</var>, ...],
      "status": <var>VolumeCurentStatus</var>,
      "storedSize": <var>int</var>,
      "syncingDataBytes": <var>int</var>,
      "syncingMetaObjects": <var>int</var>,
      "tags": {
        "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
      } <span class="opt">/* Optional */</span>
    }, ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from Either(VolumeName, SnapshotName) to VolumeStatus
<ul>
<li>Key type: The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li>
<li>Value type: <strong>VolumeStatus</strong><ul>
<li class="attribute">balancerBlocked:  (<strong><a href="#bool">bool</a></strong>): Can this volume be rebalanced, or is rebalancing impossible with the current placement policy due to for example missing or soft-ejecting drives.</li><li class="attribute">decreasedRedundancy:  (<strong><a href="#bool">bool</a></strong>): True if any of the replicas of the volume are missing.</li><li class="attribute">downBytes:  (<strong><a href="#int">int</a></strong>): The number of bytes of the volume that are not accessible at the moment.</li><li class="attribute">downDrives:  The IDs of the drives that are not accessible at the moment but needed by this volume. The volume will be in the &apos;down&apos; status until all or some of these drives reappear.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">migrating:  (<strong><a href="#bool">bool</a></strong>): True if there are tasks for reallocation of the volume.</li><li class="attribute">missingDrives:  The IDs of the drives that are not accessible at the moment. The volume has all the needed data on the rest of the disks and can continue serving requests but it is in the &apos;degraded&apos; status.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">missingTargetDrives: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">name:  The volume&apos;s name.The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">onDiskSize:  (<strong><a href="#int">int</a></strong>): The actual size that the objects of this volume occupy on the disks.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">snapshot:  (<strong><a href="#bool">bool</a></strong>): True if this response describes a snapshot instead of a volume.</li><li class="attribute">softEjectingDrives: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">status:  (<strong><a href="#VolumeCurentStatus">VolumeCurentStatus</a></strong>): up - The volume is operational. up soon - Synchronizing versions of objects after a disk has come back up. data lost - The last copy of some of the data in the volume has been lost. down - Some or all of the objects of the volume are missing and the volume is not in a state to continue serving operations.</li><li class="attribute">storedSize:  (<strong><a href="#int">int</a></strong>): The number of bytes of client data on the volume. This does not take into account the StorPool replication and overhead, thus it is never larger than the volume size.</li><li class="attribute">syncingDataBytes:  (<strong><a href="#int">int</a></strong>): The total number of bytes in objects currently being synchronized (degraded objects or objects with not yet known version)</li><li class="attribute">syncingMetaObjects:  (<strong><a href="#int">int</a></strong>): The number of objects currently being synchronized (degraded objects or objects with not yet known version)</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumesSpace">List total used space by each volume (<strong>VolumesSpace</strong>)</h3>
<p>List estimated total virtual space used by each volume.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumesSpace HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumesSpace</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "spaceUsed": <var>long</var>,
    "storedSize": <var>long</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>VolumeSpace</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of this volume.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">spaceUsed:  (<strong><a href="#long">long</a></strong>): The total number of bytes of client data that on this volume. This includes data that is stored in all the volume&apos;s parents</li><li class="attribute">storedSize:  (<strong><a href="#long">long</a></strong>): The number of bytes of client data on this volume. This does not take into account the StorPool replication and overhead, thus it is never larger than the volume size.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="Volume">List a single volume (<strong>Volume</strong>)</h3>
<p>Same as VolumeList but only return information about a given volume.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/Volume/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/Volume/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>VolumeSummary</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of this volume.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeDescribe">Describe a volume (<strong>VolumeDescribe</strong>)</h3>
<p>Return detailed information about the distribution of the volume&apos;s data on
	the disks.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeDescribe/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeDescribe/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objects": [[<var>DiskID</var>, ...], ...],
    "objectsCount": <var>int</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "targetDiskSets": [[<var>DiskID</var>, ...], ...],
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>Volume</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of this volume.</li><li class="attribute">objects:  Where each object is actually stored.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">targetDiskSets:  Sets of disks that the volume&apos;s data should be stored on.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeGetInfo">Get volume info (<strong>VolumeGetInfo</strong>)</h3>
<p>Return general information about the distribution of the volume&apos;s data on
	the disks.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeGetInfo/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeGetInfo/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "disksCount": <var>int</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "objectsPerChain": [{
      "count": <var>int</var>,
      "disks": [<var>DiskID</var>, ...]
    }, ...],
    "objectsPerDisk": {
      "<var>DiskID</var>": <var>int</var>, ...
    },
    "objectsPerDiskSet": [{
      "count": <var>int</var>,
      "disks": [<var>DiskID</var>, ...]
    }, ...],
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeInfo</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">disksCount:  (<strong><a href="#int">int</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of this volume.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">objectsPerChain: <ul>Element type: <strong>VolumeChainStat</strong><ul>
<li class="attribute">count:  (<strong><a href="#int">int</a></strong>): The number of objects on the disks.</li><li class="attribute">disks:  IDs of the disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li></ul>

</li></ul>
</li><li class="attribute">objectsPerDisk: A dict from DiskID to int
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: <strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">objectsPerDiskSet: <ul>Element type: <strong>VolumeChainStat</strong><ul>
<li class="attribute">count:  (<strong><a href="#int">int</a></strong>): The number of objects on the disks.</li><li class="attribute">disks:  IDs of the disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li></ul>

</li></ul>
</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeListSnapshots">List the parent snapshots of a volume (<strong>VolumeListSnapshots</strong>)</h3>
<p>List a volume&apos;s parent snapshots in the same format as
	VolumeList</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeListSnapshots/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeListSnapshots/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "autoName": <var>bool</var>,
    "bound": <var>bool</var>,
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "deleted": <var>bool</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "globalId": <var>Global Volume Id</var>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>SnapshotName</var>,
    "objectsCount": <var>int</var>,
    "onVolume": <var>VolumeName</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "recoveringFromRemote": <var>bool</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "targetDeleteDate": <var>int</var> <span class="opt">/* Optional */</span>,
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "transient": <var>bool</var>,
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>SnapshotSummary</strong><ul>
<li class="attribute">autoName:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot anonymous.</li><li class="attribute">bound:  (<strong><a href="#bool">bool</a></strong>): Is this a bound snapshot. Bound snapshots are garbage-collected as soon as they remain childless and are no longer attached.</li><li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">deleted:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot currently being deleted.</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">globalId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The global snapshot identifier.</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of this snapshot</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">onVolume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume that this is a parent of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">recoveringFromRemote:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot&apos;s data currently being transferred from a remote location.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">targetDeleteDate:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): Scheduled date for the snapshot to be deleted. Unix timestamp</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">transient:  (<strong><a href="#bool">bool</a></strong>): Is this a transient snapshot. Transient snapshots are internally created when cloning a volume. They cannot be attached as they may be garbage-collected at any time.</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeCreate">Create a new volume (<strong>VolumeCreate</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeCreate HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "baseOn": <var>VolumeName</var> <span class="opt">/* Optional */</span>,
  "bw": <var>Bandwidth</var> <span class="opt">/* Optional */</span>,
  "iops": <var>IOPS</var> <span class="opt">/* Optional */</span>,
  "name": <var>VolumeName</var>,
  "parent": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeHead": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "reuseServer": <var>bool</var> <span class="opt">/* Optional */</span>,
  "size": <var>Size</var> <span class="opt">/* Optional */</span>,
  "tags": {
    "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
  } <span class="opt">/* Optional */</span>,
  "template": <var>VolumeTemplateName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeCreate</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>VolumeCreateDesc</strong><ul>
<li class="attribute">baseOn:  (<span class="opt">Optional</span> <strong><a href="#VolumeName">VolumeName</a></strong>): The name of an already existing volume that the new volume is to be a copy of.</li><li class="attribute">bw:  (<span class="opt">Optional</span> <strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<span class="opt">Optional</span> <strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume to be created.</li><li class="attribute">parent:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot that the new volume is based on.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">reuseServer:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): allow placement of replicas on same server.</li><li class="attribute">size:  (<span class="opt">Optional</span> <strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Optional name=value tags.</li><li class="attribute">template:  (<span class="opt">Optional</span> <strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The name of the template that the settings of the new volume are based on.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "autoName": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOkVolumeCreate</strong><ul>
<li class="attribute">autoName:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the transient snapshot used during the creation of the volume.</li><li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeUpdate">Update a volume (<strong>VolumeUpdate</strong>)</h3>
<p>Alter the configuration of an existing volume.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeUpdate/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "bw": <var>Bandwidth</var> <span class="opt">/* Optional */</span>,
  "iops": <var>IOPS</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeHead": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "rename": <var>VolumeName</var> <span class="opt">/* Optional */</span>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "reuseServer": <var>bool</var> <span class="opt">/* Optional */</span>,
  "shrinkOk": <var>bool</var> <span class="opt">/* Optional */</span>,
  "size": <var>Size</var> <span class="opt">/* Optional */</span>,
  "sizeAdd": <var>SizeAdd</var> <span class="opt">/* Optional */</span>,
  "tags": {
    "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
  } <span class="opt">/* Optional */</span>,
  "template": <var>VolumeTemplateName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeUpdate/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeUpdateDesc</strong><ul>
<li class="attribute">bw:  (<span class="opt">Optional</span> <strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<span class="opt">Optional</span> <strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">rename:  (<span class="opt">Optional</span> <strong><a href="#VolumeName">VolumeName</a></strong>): The new name to be set.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">reuseServer:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): allow placement of replicas on same server.</li><li class="attribute">shrinkOk:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>)</li><li class="attribute">size:  (<span class="opt">Optional</span> <strong><a href="#Size">Size</a></strong>): The new size in bytes.</li><li class="attribute">sizeAdd:  (<span class="opt">Optional</span> <strong><a href="#SizeAdd">SizeAdd</a></strong>): The number of bytes that the volume&apos;s size should be increased by.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Optional name=value tags.</li><li class="attribute">template:  (<span class="opt">Optional</span> <strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The new template that the volume&apos;s settings should be based on.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeFreeze">Freeze a volume (<strong>VolumeFreeze</strong>)</h3>
<p>Convert the volume to a snapshot</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeFreeze/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "deleteAfter": <var>int</var> <span class="opt">/* Optional */</span>,
  "targetDeleteDate": <var>int</var> <span class="opt">/* Optional */</span>
} <span class="opt">/* Optional */</span></code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeFreeze/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <span class="opt">Optional</span> <strong><a href="#VolumeFreezeDesc">VolumeFreezeDesc</a></strong></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeRebase">Rebase a volume (<strong>VolumeRebase</strong>)</h3>
<p>Change the parent of the volume by choosing from the ones higher in
	the hierarchy or by rebasing it to no parent.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeRebase/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "parentName": <var>SnapshotName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeRebase/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeRebaseDesc</strong><ul>
<li class="attribute">parentName:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of one of the volume&apos;s parents on which to re-base. If left out, it will be re-based to base.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeAbandonDisk">Abandon disk (<strong>VolumeAbandonDisk</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeAbandonDisk/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "diskId": <var>DiskID</var>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeAbandonDisk/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>AbandonDiskDesc</strong><ul>
<li class="attribute">diskId:  (<strong><a href="#DiskID">DiskID</a></strong>): the disk to abandon.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeDelete">Delete a volume (<strong>VolumeDelete</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeDelete/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeDelete/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBackup">Backup a volume to a remote location (<strong>VolumeBackup</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeBackup HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "location": <var>RemoteLocationName</var>,
  "tags": {
    "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
  } <span class="opt">/* Optional */</span>,
  "volume": <var>VolumeName</var>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBackup</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>VolumeBackupDesc</strong><ul>
<li class="attribute">location:  (<strong><a href="#RemoteLocationName">RemoteLocationName</a></strong>): The remote location to backup to.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">volume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume to backup.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "autoName": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>,
    "remoteId": <var>Global Volume Id</var> <span class="opt">/* Optional */</span>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOkVolumeBackup</strong><ul>
<li class="attribute">autoName:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the transient snapshot used during the creation of the volume.</li><li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li><li class="attribute">remoteId:  (<span class="opt">Optional</span> <strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The globally unique id of the backup</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumesGroupBackup">Backup a group of volumes to a remote location (<strong>VolumesGroupBackup</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumesGroupBackup HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "location": <var>RemoteLocationName</var>,
  "tags": {
    "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
  } <span class="opt">/* Optional */</span>,
  "volumes": [<var>VolumeName</var>, ...]
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumesGroupBackup</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>VolumesGroupBackupDesc</strong><ul>
<li class="attribute">location:  (<strong><a href="#RemoteLocationName">RemoteLocationName</a></strong>): The remote location to backup to.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">volumes:  The names of the volumes to backup.<ul>Element type: <strong><a href="#VolumeName">VolumeName</a></strong>
</li></ul>
</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "backups": {
      "<var>VolumeName</var>": {
        "remoteId": <var>Global Volume Id</var>
      }, ...
    },
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOkVolumesGroupBackup</strong><ul>
<li class="attribute">backups:  The mapping of volume names to backup id.A dict from VolumeName to VolumesGroupBackupSingle
<ul>
<li>Key type: <strong><a href="#VolumeName">VolumeName</a></strong></li>
<li>Value type: <strong>VolumesGroupBackupSingle</strong><ul>
<li class="attribute">remoteId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): the globally unique id of the backup.</li></ul>
</li>
</ul>
</li><li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Snapshots">Snapshots</h2>
<p>Snapshots in their essence are very similar to volumes in the sense
that many operations supported by volumes are also supported by
snapshots (all except write-related operations). They can not be
modified and play an essential role in copy-on-write scenarios.</p>
<h3 id="SnapshotsList">List all snapshots (<strong>SnapshotsList</strong>)</h3>
<p>List all the snapshots in the cluster in the same
	format as VolumeList.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/SnapshotsList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotsList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "autoName": <var>bool</var>,
    "bound": <var>bool</var>,
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "deleted": <var>bool</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "globalId": <var>Global Volume Id</var>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>SnapshotName</var>,
    "objectsCount": <var>int</var>,
    "onVolume": <var>VolumeName</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "recoveringFromRemote": <var>bool</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "targetDeleteDate": <var>int</var> <span class="opt">/* Optional */</span>,
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "transient": <var>bool</var>,
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>SnapshotSummary</strong><ul>
<li class="attribute">autoName:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot anonymous.</li><li class="attribute">bound:  (<strong><a href="#bool">bool</a></strong>): Is this a bound snapshot. Bound snapshots are garbage-collected as soon as they remain childless and are no longer attached.</li><li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">deleted:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot currently being deleted.</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">globalId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The global snapshot identifier.</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of this snapshot</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">onVolume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume that this is a parent of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">recoveringFromRemote:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot&apos;s data currently being transferred from a remote location.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">targetDeleteDate:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): Scheduled date for the snapshot to be deleted. Unix timestamp</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">transient:  (<strong><a href="#bool">bool</a></strong>): Is this a transient snapshot. Transient snapshots are internally created when cloning a volume. They cannot be attached as they may be garbage-collected at any time.</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotsSpace">List snapshots space estimations (<strong>SnapshotsSpace</strong>)</h3>
<p>List estimated virtual space used by each snapshot.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/SnapshotsSpace HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotsSpace</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "autoName": <var>bool</var>,
    "bound": <var>bool</var>,
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "deleted": <var>bool</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "globalId": <var>Global Volume Id</var>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>SnapshotName</var>,
    "objectsCount": <var>int</var>,
    "onVolume": <var>VolumeName</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "recoveringFromRemote": <var>bool</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "spaceUsed": <var>long</var>,
    "storedSize": <var>long</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "targetDeleteDate": <var>int</var> <span class="opt">/* Optional */</span>,
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "transient": <var>bool</var>,
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>SnapshotSpace</strong><ul>
<li class="attribute">autoName:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot anonymous.</li><li class="attribute">bound:  (<strong><a href="#bool">bool</a></strong>): Is this a bound snapshot. Bound snapshots are garbage-collected as soon as they remain childless and are no longer attached.</li><li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">deleted:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot currently being deleted.</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">globalId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The global snapshot identifier.</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of this snapshot</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">onVolume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume that this is a parent of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">recoveringFromRemote:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot&apos;s data currently being transferred from a remote location.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">spaceUsed:  (<strong><a href="#long">long</a></strong>): The number of bytes of client data that will be freed if this snapshot is deleted.</li><li class="attribute">storedSize:  (<strong><a href="#long">long</a></strong>): The number of bytes of client data on this snapshot. This does not take into account the StorPool replication and overhead, thus it is never larger than the volume size.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">targetDeleteDate:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): Scheduled date for the snapshot to be deleted. Unix timestamp</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">transient:  (<strong><a href="#bool">bool</a></strong>): Is this a transient snapshot. Transient snapshots are internally created when cloning a volume. They cannot be attached as they may be garbage-collected at any time.</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="Snapshot">List a single snapshot (<strong>Snapshot</strong>)</h3>
<p>Same as SnapshotList but only return information about a given snapshot.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/Snapshot/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/Snapshot/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "autoName": <var>bool</var>,
    "bound": <var>bool</var>,
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "deleted": <var>bool</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "globalId": <var>Global Volume Id</var>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>SnapshotName</var>,
    "objectsCount": <var>int</var>,
    "onVolume": <var>VolumeName</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "recoveringFromRemote": <var>bool</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "targetDeleteDate": <var>int</var> <span class="opt">/* Optional */</span>,
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "transient": <var>bool</var>,
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>SnapshotSummary</strong><ul>
<li class="attribute">autoName:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot anonymous.</li><li class="attribute">bound:  (<strong><a href="#bool">bool</a></strong>): Is this a bound snapshot. Bound snapshots are garbage-collected as soon as they remain childless and are no longer attached.</li><li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">deleted:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot currently being deleted.</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">globalId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The global snapshot identifier.</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of this snapshot</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">onVolume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume that this is a parent of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">recoveringFromRemote:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot&apos;s data currently being transferred from a remote location.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">targetDeleteDate:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): Scheduled date for the snapshot to be deleted. Unix timestamp</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">transient:  (<strong><a href="#bool">bool</a></strong>): Is this a transient snapshot. Transient snapshots are internally created when cloning a volume. They cannot be attached as they may be garbage-collected at any time.</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotDescribe">Describe a snapshot (<strong>SnapshotDescribe</strong>)</h3>
<p>Return detailed information about the distribution of the snapshot&apos;s data on the
	disks.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/SnapshotDescribe/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotDescribe/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "autoName": <var>bool</var>,
    "bound": <var>bool</var>,
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "deleted": <var>bool</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "globalId": <var>Global Volume Id</var>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>SnapshotName</var>,
    "objects": [[<var>DiskID</var>, ...], ...],
    "objectsCount": <var>int</var>,
    "onVolume": <var>VolumeName</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "recoveringFromRemote": <var>bool</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "targetDeleteDate": <var>int</var> <span class="opt">/* Optional */</span>,
    "targetDiskSets": [[<var>DiskID</var>, ...], ...],
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "transient": <var>bool</var>,
    "visibleVolumeId": <var>long</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>Snapshot</strong><ul>
<li class="attribute">autoName:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot anonymous.</li><li class="attribute">bound:  (<strong><a href="#bool">bool</a></strong>): Is this a bound snapshot. Bound snapshots are garbage-collected as soon as they remain childless and are no longer attached.</li><li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">deleted:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot currently being deleted.</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">globalId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The global snapshot identifier.</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of this snapshot</li><li class="attribute">objects:  Where each object is actually stored.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">onVolume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume that this is a parent of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">recoveringFromRemote:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot&apos;s data currently being transferred from a remote location.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">targetDeleteDate:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): Scheduled date for the snapshot to be deleted. Unix timestamp</li><li class="attribute">targetDiskSets:  Sets of disks that the volume&apos;s data should be stored on.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">transient:  (<strong><a href="#bool">bool</a></strong>): Is this a transient snapshot. Transient snapshots are internally created when cloning a volume. They cannot be attached as they may be garbage-collected at any time.</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotGetInfo">Get snapshot info (<strong>SnapshotGetInfo</strong>)</h3>
<p>Return general information about the distribution of the snapshot&apos;s data on the
	disks.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/SnapshotGetInfo/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotGetInfo/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "autoName": <var>bool</var>,
    "bound": <var>bool</var>,
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "deleted": <var>bool</var>,
    "disksCount": <var>int</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "globalId": <var>Global Volume Id</var>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>SnapshotName</var>,
    "objectsCount": <var>int</var>,
    "objectsPerChain": [{
      "count": <var>int</var>,
      "disks": [<var>DiskID</var>, ...]
    }, ...],
    "objectsPerDisk": {
      "<var>DiskID</var>": <var>int</var>, ...
    },
    "objectsPerDiskSet": [{
      "count": <var>int</var>,
      "disks": [<var>DiskID</var>, ...]
    }, ...],
    "onVolume": <var>VolumeName</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "recoveringFromRemote": <var>bool</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "tags": {
      "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
    } <span class="opt">/* Optional */</span>,
    "targetDeleteDate": <var>int</var> <span class="opt">/* Optional */</span>,
    "templateId": <var>long</var> <span class="opt">/* Internal */</span>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "transient": <var>bool</var>,
    "visibleVolumeId": <var>long</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>SnapshotInfo</strong><ul>
<li class="attribute">autoName:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot anonymous.</li><li class="attribute">bound:  (<strong><a href="#bool">bool</a></strong>): Is this a bound snapshot. Bound snapshots are garbage-collected as soon as they remain childless and are no longer attached.</li><li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The volume&apos;s creation timestamp (UNIX timestamp)</li><li class="attribute">deleted:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot currently being deleted.</li><li class="attribute">disksCount:  (<strong><a href="#int">int</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">globalId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The global snapshot identifier.</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of this snapshot</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">objectsPerChain: <ul>Element type: <strong>VolumeChainStat</strong><ul>
<li class="attribute">count:  (<strong><a href="#int">int</a></strong>): The number of objects on the disks.</li><li class="attribute">disks:  IDs of the disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li></ul>

</li></ul>
</li><li class="attribute">objectsPerDisk: A dict from DiskID to int
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: <strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">objectsPerDiskSet: <ul>Element type: <strong>VolumeChainStat</strong><ul>
<li class="attribute">count:  (<strong><a href="#int">int</a></strong>): The number of objects on the disks.</li><li class="attribute">disks:  IDs of the disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li></ul>

</li></ul>
</li><li class="attribute">onVolume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume that this is a parent of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume/snapshot&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">recoveringFromRemote:  (<strong><a href="#bool">bool</a></strong>): Is this snapshot&apos;s data currently being transferred from a remote location.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume/snapshots&apos;s size in bytes.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the volume.</li><li class="attribute">targetDeleteDate:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): Scheduled date for the snapshot to be deleted. Unix timestamp</li><li class="attribute">templateId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">templateName:  The template that the volume/snapshot&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">transient:  (<strong><a href="#bool">bool</a></strong>): Is this a transient snapshot. Transient snapshots are internally created when cloning a volume. They cannot be attached as they may be garbage-collected at any time.</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeSnapshot">Snapshot a volume (<strong>VolumeSnapshot</strong>)</h3>
<p>Create a snapshot of the given volume; the snapshot becomes the parent of
	the volume.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeSnapshot/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "bind": <var>bool</var> <span class="opt">/* Optional */</span>,
  "deleteAfter": <var>int</var> <span class="opt">/* Optional */</span>,
  "name": <var>VolumeName</var> <span class="opt">/* Optional */</span>,
  "tags": {
    "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
  } <span class="opt">/* Optional */</span>,
  "targetDeleteDate": <var>int</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeSnapshot/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeSnapshotDesc</strong><ul>
<li class="attribute">bind:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): If true, the lifetime of the newly created snapshot will be bound to the lifetime of its children. As soon as it remains childless the snapshot will be garbage-collected.</li><li class="attribute">deleteAfter:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): If not 0 set targetDeleteDate relative to the current time on the mgmt node. This value will be added to the current time as seconds and set as targetDeleteDate.</li><li class="attribute">name:  (<span class="opt">Optional</span> <strong><a href="#VolumeName">VolumeName</a></strong>): The name of the newly created snapshot. If not specified, a name will be auto-generated by the StorPool management service.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the snapshot.</li><li class="attribute">targetDeleteDate:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): If not 0 set absolute targetDeleteDate for the new snapshot. Unix timestamp. targetDeleteDate can not be set in the past</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "autoName": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOkVolumeCreate</strong><ul>
<li class="attribute">autoName:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the transient snapshot used during the creation of the volume.</li><li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotUpdate">Update a snapshot (<strong>SnapshotUpdate</strong>)</h3>
<p>Alter the configuration of an existing snapshot.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotUpdate/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "bind": <var>bool</var> <span class="opt">/* Optional */</span>,
  "bw": <var>Bandwidth</var> <span class="opt">/* Optional */</span>,
  "deleteAfter": <var>int</var> <span class="opt">/* Optional */</span>,
  "iops": <var>IOPS</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeHead": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "rename": <var>VolumeName</var> <span class="opt">/* Optional */</span>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "reuseServer": <var>bool</var> <span class="opt">/* Optional */</span>,
  "tags": {
    "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
  } <span class="opt">/* Optional */</span>,
  "targetDeleteDate": <var>int</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotUpdate/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>SnapshotUpdateDesc</strong><ul>
<li class="attribute">bind:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): When true bind this snapshot, when false - unbind it. If not set or missing - no change.</li><li class="attribute">bw:  (<span class="opt">Optional</span> <strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">deleteAfter:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): set targetDeleteDate relative to the current time on the mgmt node. If not 0 this value will be added to the current time as seconds and set as targetDeleteDate. If 0 it will discard previous targetDeleteDate</li><li class="attribute">iops:  (<span class="opt">Optional</span> <strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">rename:  (<span class="opt">Optional</span> <strong><a href="#VolumeName">VolumeName</a></strong>): The new name to be set.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">reuseServer:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): allow placement of replicas on same server.</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the snapshot.</li><li class="attribute">targetDeleteDate:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): set absolute targetDeleteDate, or 0 to disable automatic deleting. Unix timestamp. targetDeleteDate can not be set in the past</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotRebase">Rebase a snapshot (<strong>SnapshotRebase</strong>)</h3>
<p>Change the parent of the snapshot by choosing from the ones higher in
	the hierarchy or by rebasing it to no parent.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotRebase/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "parentName": <var>SnapshotName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotRebase/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeRebaseDesc</strong><ul>
<li class="attribute">parentName:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of one of the volume&apos;s parents on which to re-base. If left out, it will be re-based to base.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeAbandonDisk">Abandon disk (<strong>VolumeAbandonDisk</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeAbandonDisk/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "diskId": <var>DiskID</var>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeAbandonDisk/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>AbandonDiskDesc</strong><ul>
<li class="attribute">diskId:  (<strong><a href="#DiskID">DiskID</a></strong>): the disk to abandon.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotDelete">Delete a snapshot (<strong>SnapshotDelete</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotDelete/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotDelete/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotDeleteById">Delete a snapshot by global id (<strong>SnapshotDeleteById</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotDeleteById/{globalVolumeId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotDeleteById/{globalVolumeId}</em></li>
<li>Arguments: 
<ul>
<li>globalVolumeId - <strong>Global Volume Id</strong>: <em>string, regex [a-z0-9]+\.[a-z0-9]\.[a-z0-9]+$</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumesGroupSnapshot">Create consistent snapshots of a group of volumes (<strong>VolumesGroupSnapshot</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumesGroupSnapshot HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "volumes": [{
    "name": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
    "volume": <var>VolumeName</var>
  }, ...]
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumesGroupSnapshot</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>GroupSnapshotsSpec</strong><ul>
<li class="attribute">volumes:  The volumes to create snapshots of.<ul>Element type: <strong>GroupSnapshotSpec</strong><ul>
<li class="attribute">name:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot to create.</li><li class="attribute">volume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume to create a snapshot of.</li></ul>

</li></ul>
</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "volumes": [{
      "remoteId": <var>Global Volume Id</var>,
      "snapshot": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
      "volume": <var>VolumeName</var>
    }, ...]
  }
}
</code></pre></li>
<li>Response Data:
<strong>GroupSnapshotsResult</strong><ul>
<li class="attribute">volumes:  The volumes to create snapshots of.<ul>Element type: <strong>GroupSnapshotResult</strong><ul>
<li class="attribute">remoteId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The globally unique id of the created snapshot.</li><li class="attribute">snapshot:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the created snapshot.</li><li class="attribute">volume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the source volume.</li></ul>

</li></ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotFromRemote">Copy a snapshot from a remote location (<strong>SnapshotFromRemote</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotFromRemote HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "export": <var>bool</var> <span class="opt">/* Optional */</span>,
  "name": <var>VolumeName</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeHead": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "remoteId": <var>Global Volume Id</var>,
  "remoteLocation": <var>RemoteLocationName</var>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "tags": {
    "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
  } <span class="opt">/* Optional */</span>,
  "template": <var>VolumeTemplateName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotFromRemote</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>SnapshotFromRemoteDesc</strong><ul>
<li class="attribute">export:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): Auto-export the snapshot after creating it. e.g. for backup.</li><li class="attribute">name:  (<span class="opt">Optional</span> <strong><a href="#VolumeName">VolumeName</a></strong>): The name of the new snapshot.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">remoteId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The global snapshot identifier.</li><li class="attribute">remoteLocation:  (<strong><a href="#RemoteLocationName">RemoteLocationName</a></strong>): The name of the remote location to fetch the snapshot from.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>)</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Arbitrary short name/value pairs stored with the snapshot.</li><li class="attribute">template:  (<span class="opt">Optional</span> <strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>)</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotExport">Allow a remote location to access a local snapshot (<strong>SnapshotExport</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotExport HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "location": <var>RemoteLocationName</var>,
  "snapshot": <var>SnapshotName</var>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotExport</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>SnapshotExportDesc</strong><ul>
<li class="attribute">location:  (<strong><a href="#RemoteLocationName">RemoteLocationName</a></strong>): The name of the remote location to grant access to.</li><li class="attribute">snapshot:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotUnexport">Revoke a remote location&apos;s access to a local snapshot (<strong>SnapshotUnexport</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotUnexport HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "all": <var>bool</var> <span class="opt">/* Optional */</span>,
  "force": <var>bool</var> <span class="opt">/* Optional */</span>,
  "location": <var>RemoteLocationName</var> <span class="opt">/* Optional */</span>,
  "snapshot": <var>SnapshotName</var>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotUnexport</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>SnapshotUnexportDesc</strong><ul>
<li class="attribute">all:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): Revoke access from all locations.</li><li class="attribute">force:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): Don&apos;t check if the snapshot is still recovering in the remote location.</li><li class="attribute">location:  (<span class="opt">Optional</span> <strong><a href="#RemoteLocationName">RemoteLocationName</a></strong>): The name of the remote location to revoke access from.</li><li class="attribute">snapshot:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="ExportsList">List exported snapshots (<strong>ExportsList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ExportsList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ExportsList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>str, default=&quot;exports&quot;</var>": [{
      "backingUp": <var>bool</var> <span class="opt">/* Optional */</span>,
      "globalId": <var>Global Volume Id</var>,
      "location": <var>RemoteLocationName</var>,
      "snapshot": <var>SnapshotName</var>,
      "visibleVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
      "volumeId": <var>long</var> <span class="opt">/* Internal */</span>
    }, ...], ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from str, default=&quot;exports&quot; to [Export]
<ul>
<li>Key type: <strong><a href="#str, default=&quot;exports&quot;">str, default=&quot;exports&quot;</a></strong></li>
<li>Value type: <ul>Element type: <strong>Export</strong><ul>
<li class="attribute">backingUp:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): Is this a backup in making</li><li class="attribute">globalId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The global snapshot identifier.</li><li class="attribute">location:  (<strong><a href="#RemoteLocationName">RemoteLocationName</a></strong>): Name of the location the snapshot is exported to</li><li class="attribute">snapshot:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot.</li><li class="attribute">visibleVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">volumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li></ul>

</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotsRemoteList">List the available remote snapshots (<strong>SnapshotsRemoteList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/SnapshotsRemoteList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotsRemoteList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>str, default=&quot;snapshots&quot;</var>": [{
      "creationTimestamp": <var>long</var>,
      "localSnapshot": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
      "location": <var>RemoteLocationName</var>,
      "name": <var>VolumeName</var>,
      "onVolume": <var>VolumeName</var> <span class="opt">/* Optional */</span>,
      "remoteId": <var>Global Volume Id</var>,
      "size": <var>Size</var>
    }, ...], ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from str, default=&quot;snapshots&quot; to [RemoteSnapshot]
<ul>
<li>Key type: <strong><a href="#str, default=&quot;snapshots&quot;">str, default=&quot;snapshots&quot;</a></strong></li>
<li>Value type: <ul>Element type: <strong>RemoteSnapshot</strong><ul>
<li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>): The snapshot&apos;s creation timestamp (UNIX timestamp).</li><li class="attribute">localSnapshot:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the local snapshot (if any) which is a copy of the remote snapshot.</li><li class="attribute">location:  (<strong><a href="#RemoteLocationName">RemoteLocationName</a></strong>): Where the snapshot is located.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the snapshot.</li><li class="attribute">onVolume:  (<span class="opt">Optional</span> <strong><a href="#VolumeName">VolumeName</a></strong>): The name of the local volume (if any) on which the snapshot was created.</li><li class="attribute">remoteId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): The global snapshot identifier.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The snapshots&apos;s size in bytes.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotsRemoteUnexport">Instruct the remote location that we will no longer use those snapshots (<strong>SnapshotsRemoteUnexport</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotsRemoteUnexport HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "remoteSnapshots": [{
    "deleteAfter": <var>int</var> <span class="opt">/* Optional */</span>,
    "globalSnapshotId": <var>Global Volume Id</var>,
    "location": <var>RemoteLocationName</var>,
    "targetDeleteDate": <var>int</var> <span class="opt">/* Optional */</span>
  }, ...]
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotsRemoteUnexport</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>SnapshotsRemoteUnexport</strong><ul>
<li class="attribute">remoteSnapshots:  list of SnapshotRemoteUnexportDesc<ul>Element type: <strong>SnapshotRemoteUnexportDesc</strong><ul>
<li class="attribute">deleteAfter:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): same as targetDeleteDate, but time in secs relative to current time on the mgmt node</li><li class="attribute">globalSnapshotId:  (<strong><a href="#Global Volume Id">Global Volume Id</a></strong>): the id of the snapshot to be unexported</li><li class="attribute">location:  (<strong><a href="#RemoteLocationName">RemoteLocationName</a></strong>): name of the location to unexport from</li><li class="attribute">targetDeleteDate:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): if not 0 instruct the remote location to delete the snapshot at the specified date. Remote side may not allow this due to configuration or the snapshot beeeing used</li></ul>

</li></ul>
</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Attachments">Attachments</h2>
<p></p>
<h3 id="AttachmentsList">List all attachments (<strong>AttachmentsList</strong>)</h3>
<p>List the volumes and snapshots currently attached to clients along with
	the read/write rights of each attachment.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/AttachmentsList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/AttachmentsList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "client": <var>ClientID</var>,
    "pos": <var>AttachmentPos</var>,
    "rights": <var>AttachmentRights</var>,
    "snapshot": <var>bool</var>,
    "volume": <var>VolumeName</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>AttachmentDesc</strong><ul>
<li class="attribute">client:  (<strong><a href="#ClientID">ClientID</a></strong>): The ID of the client on which it is attached.</li><li class="attribute">pos:  (<strong><a href="#AttachmentPos">AttachmentPos</a></strong>): The attachment position on the client; used by the StorPool client to form the name of the internal /dev/spN device node.</li><li class="attribute">rights:  (<strong><a href="#AttachmentRights">AttachmentRights</a></strong>): Whether the volume is attached as read only or read/write; always ro for snapshots.</li><li class="attribute">snapshot:  (<strong><a href="#bool">bool</a></strong>): Whether it is a snapshot or a volume.</li><li class="attribute">volume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the attached volume.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumesReassign">Reassign volumes and/or snapshots (<strong>VolumesReassign</strong>)</h3>
<p>Perform bulk attach/detach and attachment rights modification.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumesReassign HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

[Either({
  "detach": Either(<var>&quot;all&quot;</var>, [<var>ClientID</var>, ...]) <span class="opt">/* Optional */</span>,
  "force": <var>bool, default=false</var>,
  "ro": [<var>ClientID</var>, ...] <span class="opt">/* Optional */</span>,
  "rw": [<var>ClientID</var>, ...] <span class="opt">/* Optional */</span>,
  "volume": <var>VolumeName</var>
}, {
  "detach": Either(<var>&quot;all&quot;</var>, [<var>ClientID</var>, ...]) <span class="opt">/* Optional */</span>,
  "force": <var>bool, default=false</var>,
  "ro": [<var>ClientID</var>, ...] <span class="opt">/* Optional */</span>,
  "snapshot": <var>SnapshotName</var>
}), ...]</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumesReassign</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <ul>Element type: The value must be of one of the following types: VolumeReassignDesc, SnapshotReassignDesc.
<ul><em>Subtypes:</em>
<li><strong>VolumeReassignDesc</strong><ul>
<li class="attribute">detach:  (<span class="opt">Optional</span> <strong><a href="#Either(&quot;all&quot;, [ClientID])">Either(&quot;all&quot;, [ClientID])</a></strong>): The clients from which to detach the given volume.</li><li class="attribute">force:  (<strong><a href="#bool, default=false">bool, default=false</a></strong>): Whether to force detaching of open volumes.</li><li class="attribute">ro:  (<span class="opt">Optional</span> <strong><a href="#[ClientID]">[ClientID]</a></strong>): The clients on which to attach the volume as read only.</li><li class="attribute">rw:  (<span class="opt">Optional</span> <strong><a href="#[ClientID]">[ClientID]</a></strong>): The clients on which to attach the volume as read/write.</li><li class="attribute">volume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume to be reassigned.</li></ul>
</li>
<li><strong>SnapshotReassignDesc</strong><ul>
<li class="attribute">detach:  (<span class="opt">Optional</span> <strong><a href="#Either(&quot;all&quot;, [ClientID])">Either(&quot;all&quot;, [ClientID])</a></strong>): The clients from which to detach the given snapshot.</li><li class="attribute">force:  (<strong><a href="#bool, default=false">bool, default=false</a></strong>): Whether to force detaching of open snapshots.</li><li class="attribute">ro:  (<span class="opt">Optional</span> <strong><a href="#[ClientID]">[ClientID]</a></strong>): The clients on which to attach the snapshot.</li><li class="attribute">snapshot:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot which should be reassigned.</li></ul>
</li>
</ul>

</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumesReassignWait">Reassign volumes and/or snapshots with confirmation from the clients (<strong>VolumesReassignWait</strong>)</h3>
<p>Perform bulk attach/detach and attachment rights modification and waits for the clients to catch up.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumesReassignWait HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "attachTimeout": <var>int</var> <span class="opt">/* Optional */</span>,
  "reassign": [Either({
    "detach": Either(<var>&quot;all&quot;</var>, [<var>ClientID</var>, ...]) <span class="opt">/* Optional */</span>,
    "force": <var>bool, default=false</var>,
    "ro": [<var>ClientID</var>, ...] <span class="opt">/* Optional */</span>,
    "rw": [<var>ClientID</var>, ...] <span class="opt">/* Optional */</span>,
    "volume": <var>VolumeName</var>
  }, {
    "detach": Either(<var>&quot;all&quot;</var>, [<var>ClientID</var>, ...]) <span class="opt">/* Optional */</span>,
    "force": <var>bool, default=false</var>,
    "ro": [<var>ClientID</var>, ...] <span class="opt">/* Optional */</span>,
    "snapshot": <var>SnapshotName</var>
  }), ...]
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumesReassignWait</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>VolumesReassignWaitDesc</strong><ul>
<li class="attribute">attachTimeout:  (<span class="opt">Optional</span> <strong><a href="#int">int</a></strong>): The number of seconds to wait for missing clients to appear when attaching to them.  If not specified, wait indefinitely.  If explicitly set to 0, immediately return successfully even if any clients are missing.</li><li class="attribute">reassign:  The list of volumes and snapshots to modify the attachment settings for.<ul>Element type: The value must be of one of the following types: VolumeReassignDesc, SnapshotReassignDesc.
<ul><em>Subtypes:</em>
<li><strong>VolumeReassignDesc</strong><ul>
<li class="attribute">detach:  (<span class="opt">Optional</span> <strong><a href="#Either(&quot;all&quot;, [ClientID])">Either(&quot;all&quot;, [ClientID])</a></strong>): The clients from which to detach the given volume.</li><li class="attribute">force:  (<strong><a href="#bool, default=false">bool, default=false</a></strong>): Whether to force detaching of open volumes.</li><li class="attribute">ro:  (<span class="opt">Optional</span> <strong><a href="#[ClientID]">[ClientID]</a></strong>): The clients on which to attach the volume as read only.</li><li class="attribute">rw:  (<span class="opt">Optional</span> <strong><a href="#[ClientID]">[ClientID]</a></strong>): The clients on which to attach the volume as read/write.</li><li class="attribute">volume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume to be reassigned.</li></ul>
</li>
<li><strong>SnapshotReassignDesc</strong><ul>
<li class="attribute">detach:  (<span class="opt">Optional</span> <strong><a href="#Either(&quot;all&quot;, [ClientID])">Either(&quot;all&quot;, [ClientID])</a></strong>): The clients from which to detach the given snapshot.</li><li class="attribute">force:  (<strong><a href="#bool, default=false">bool, default=false</a></strong>): Whether to force detaching of open snapshots.</li><li class="attribute">ro:  (<span class="opt">Optional</span> <strong><a href="#[ClientID]">[ClientID]</a></strong>): The clients on which to attach the snapshot.</li><li class="attribute">snapshot:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot which should be reassigned.</li></ul>
</li>
</ul>

</li></ul>
</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Placement-Groups">Placement Groups</h2>
<p>Placement groups provide a way to specify the disks on which a volume&apos;s data
should be stored.</p>
<h3 id="PlacementGroupsList">List all placement groups (<strong>PlacementGroupsList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/PlacementGroupsList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/PlacementGroupsList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>PlacementGroupName</var>": {
      "disks": [<var>DiskID</var>, ...],
      "id": <var>int</var> <span class="opt">/* Internal */</span>,
      "name": <var>PlacementGroupName</var>
    }, ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from PlacementGroupName to PlacementGroup
<ul>
<li>Key type: <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong></li>
<li>Value type: <strong>PlacementGroup</strong><ul>
<li class="attribute">disks:  IDs of the participating disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">name:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>)</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="PlacementGroupDescribe">Describe a single placement group (<strong>PlacementGroupDescribe</strong>)</h3>
<p>Same as PlacementGroupsList but only return information about a given group.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/PlacementGroupDescribe/{placementGroupName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/PlacementGroupDescribe/{placementGroupName}</em></li>
<li>Arguments: 
<ul>
<li>placementGroupName - <strong>PlacementGroupName</strong>: <em>a string(128), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "disks": [<var>DiskID</var>, ...],
    "id": <var>int</var> <span class="opt">/* Internal */</span>,
    "name": <var>PlacementGroupName</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>PlacementGroup</strong><ul>
<li class="attribute">disks:  IDs of the participating disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">name:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>)</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="PlacementGroupUpdate">Create and/or update a placement group (<strong>PlacementGroupUpdate</strong>)</h3>
<p>If a group by the specified name does not exist, it will be created.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/PlacementGroupUpdate/{placementGroupName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "addDisks": [<var>DiskID</var>, ...],
  "rename": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "rmDisks": [<var>DiskID</var>, ...]
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/PlacementGroupUpdate/{placementGroupName}</em></li>
<li>Arguments: 
<ul>
<li>placementGroupName - <strong>PlacementGroupName</strong>: <em>a string(128), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <strong>PlacementGroupUpdateDesc</strong><ul>
<li class="attribute">addDisks:  IDs of the disks to add to this group.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">rename:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The new name of the placement group.</li><li class="attribute">rmDisks:  IDs of the disks to be removed from this group.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="PlacementGroupDelete">Delete a placement group (<strong>PlacementGroupDelete</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/PlacementGroupDelete/{placementGroupName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/PlacementGroupDelete/{placementGroupName}</em></li>
<li>Arguments: 
<ul>
<li>placementGroupName - <strong>PlacementGroupName</strong>: <em>a string(128), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="FaultSetsList">List all fault sets (<strong>FaultSetsList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/FaultSetsList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/FaultSetsList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>PlacementGroupName</var>": {
      "name": <var>PlacementGroupName</var>,
      "servers": [<var>ServerID</var>, ...]
    }, ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from PlacementGroupName to FaultSet
<ul>
<li>Key type: <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong></li>
<li>Value type: <strong>FaultSet</strong><ul>
<li class="attribute">name:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>)</li><li class="attribute">servers:  List of servers in one fault set<ul>Element type: <strong><a href="#ServerID">ServerID</a></strong>
</li></ul>
</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Volume-Templates">Volume Templates</h2>
<p>Templates are a set of rules used for creating many similar volumes.</p>
<h3 id="VolumeTemplatesList">List all volume templates (<strong>VolumeTemplatesList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeTemplatesList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplatesList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "bw": <var>Bandwidth</var>,
    "id": <var>int</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeTemplateName</var>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": Either(<var>&quot;-&quot;</var>, <var>Replication</var>),
    "reuseServer": <var>bool</var> <span class="opt">/* Optional */</span>,
    "size": Either(<var>&quot;-&quot;</var>, <var>Size</var>)
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>VolumeTemplateDesc</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The name of the template.</li><li class="attribute">parentName:  The name of the snapshot on which volumes will be based.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  A default number of copies to be kept by StorPool.The value must be of one of the following types: &quot;-&quot;, Replication.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;-&quot;">&quot;-&quot;</a></strong></li>
<li><strong><a href="#Replication">Replication</a></strong></li>
</ul>
</li><li class="attribute">reuseServer:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): allow placement of replicas on same server.</li><li class="attribute">size:  A default size for the volumes (in bytes).The value must be of one of the following types: &quot;-&quot;, Size.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;-&quot;">&quot;-&quot;</a></strong></li>
<li><strong><a href="#Size">Size</a></strong></li>
</ul>
</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeTemplatesStatus">List the status of all volume templates (<strong>VolumeTemplatesStatus</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeTemplatesStatus HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplatesStatus</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "availablePlaceAll": <var>long</var>,
    "availablePlaceHead": <var>long</var>,
    "availablePlaceTail": <var>long</var>,
    "capacityPlaceAll": <var>long</var>,
    "capacityPlaceHead": <var>long</var>,
    "capacityPlaceTail": <var>long</var>,
    "id": <var>int</var> <span class="opt">/* Internal */</span>,
    "name": <var>VolumeTemplateName</var>,
    "onDiskSize": <var>long</var>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "removingSnapshotsCount": <var>int</var>,
    "replication": Either(<var>&quot;-&quot;</var>, <var>Replication</var>),
    "size": Either(<var>0</var>, <var>Size</var>),
    "snapshotsCount": <var>int</var>,
    "stored": {
      "capacity": <var>int</var>,
      "free": <var>int</var>,
      "internal": {
        "u1": <var>int</var>,
        "u2": <var>int</var>,
        "u3": <var>int</var>
      } <span class="opt">/* Internal */</span>,
      "placeAll": {
        "capacity": <var>int</var>,
        "free": <var>int</var>,
        "internal": {
          "u1": <var>int</var>,
          "u2": <var>int</var>,
          "u3": <var>int</var>
        } <span class="opt">/* Internal */</span>
      },
      "placeHead": {
        "capacity": <var>int</var>,
        "free": <var>int</var>,
        "internal": {
          "u1": <var>int</var>,
          "u2": <var>int</var>,
          "u3": <var>int</var>
        } <span class="opt">/* Internal */</span>
      },
      "placeTail": {
        "capacity": <var>int</var>,
        "free": <var>int</var>,
        "internal": {
          "u1": <var>int</var>,
          "u2": <var>int</var>,
          "u3": <var>int</var>
        } <span class="opt">/* Internal */</span>
      }
    },
    "storedSize": <var>long</var>,
    "totalSize": Either(<var>0</var>, <var>Size</var>),
    "volumesCount": <var>int</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>VolumeTemplateStatusDesc</strong><ul>
<li class="attribute">availablePlaceAll:  (<strong><a href="#long">long</a></strong>): An estimate of the available space on all the disks in this template&apos;s placeAll placement group.</li><li class="attribute">availablePlaceHead:  (<strong><a href="#long">long</a></strong>): An estimate of the available space on all the disks in this template&apos;s placeHead placement group.</li><li class="attribute">availablePlaceTail:  (<strong><a href="#long">long</a></strong>): An estimate of the available space on all the disks in this template&apos;s placeTail placement group.</li><li class="attribute">capacityPlaceAll:  (<strong><a href="#long">long</a></strong>): An estimate of the total physical space on all the disks in this template&apos;s placeAll placement group.</li><li class="attribute">capacityPlaceHead:  (<strong><a href="#long">long</a></strong>): An estimate of the total physical space on all the disks in this template&apos;s placeHead placement group.</li><li class="attribute">capacityPlaceTail:  (<strong><a href="#long">long</a></strong>): An estimate of the total physical space on all the disks in this template&apos;s placeTail placement group.</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">name:  (<strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The name of the template.</li><li class="attribute">onDiskSize:  (<strong><a href="#long">long</a></strong>): The actual on-disk number of bytes occupied by all the volumes based on this template.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">removingSnapshotsCount:  (<strong><a href="#int">int</a></strong>): The number of snapshots based on this template currently being deleted.</li><li class="attribute">replication:  The number of copies to be kept by StorPool if defined for this template, otherwise &quot;-&quot;.The value must be of one of the following types: &quot;-&quot;, Replication.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;-&quot;">&quot;-&quot;</a></strong></li>
<li><strong><a href="#Replication">Replication</a></strong></li>
</ul>
</li><li class="attribute">size:  The number of bytes of all volumes based on this template, not counting the StorPool replication and checksums overhead.The value must be of one of the following types: 0, Size.
<ul><em>Subtypes:</em>
<li><strong><a href="#0">0</a></strong></li>
<li><strong><a href="#Size">Size</a></strong></li>
</ul>
</li><li class="attribute">snapshotsCount:  (<strong><a href="#int">int</a></strong>): The number of snapshots based on this template (incl. snapshots currently being deleted).</li><li class="attribute">stored:  Estimated client data capacity and free space.<ul>
<li class="attribute">capacity:  (<strong><a href="#int">int</a></strong>): Estimated total client data capacity.</li><li class="attribute">free:  (<strong><a href="#int">int</a></strong>): Estimated free space remaining.</li><li class="attribute">internal:  (<span class="opt">Internal</span> <strong><a href="#VolumeTemplateSpaceEstInternal">VolumeTemplateSpaceEstInternal</a></strong>)</li><li class="attribute">placeAll:  placeAll placement group estimations.<ul>
<li class="attribute">capacity:  (<strong><a href="#int">int</a></strong>): Estimated total client data capacity.</li><li class="attribute">free:  (<strong><a href="#int">int</a></strong>): Estimated free space remaining.</li><li class="attribute">internal:  (<span class="opt">Internal</span> <strong><a href="#VolumeTemplateSpaceEstInternal">VolumeTemplateSpaceEstInternal</a></strong>)</li></ul>
</li><li class="attribute">placeHead:  placeHead placement group estimations.<ul>
<li class="attribute">capacity:  (<strong><a href="#int">int</a></strong>): Estimated total client data capacity.</li><li class="attribute">free:  (<strong><a href="#int">int</a></strong>): Estimated free space remaining.</li><li class="attribute">internal:  (<span class="opt">Internal</span> <strong><a href="#VolumeTemplateSpaceEstInternal">VolumeTemplateSpaceEstInternal</a></strong>)</li></ul>
</li><li class="attribute">placeTail:  placeTail placement group estimations.<ul>
<li class="attribute">capacity:  (<strong><a href="#int">int</a></strong>): Estimated total client data capacity.</li><li class="attribute">free:  (<strong><a href="#int">int</a></strong>): Estimated free space remaining.</li><li class="attribute">internal:  (<span class="opt">Internal</span> <strong><a href="#VolumeTemplateSpaceEstInternal">VolumeTemplateSpaceEstInternal</a></strong>)</li></ul>
</li></ul>
</li><li class="attribute">storedSize:  (<strong><a href="#long">long</a></strong>): The number of bytes of client data on all the volumes based on this template. This does not take into account the StorPool replication and overhead, thus it is never larger than the volume size.</li><li class="attribute">totalSize:  The number of bytes of all volumes based on this template, including the StorPool replication overhead.The value must be of one of the following types: 0, Size.
<ul><em>Subtypes:</em>
<li><strong><a href="#0">0</a></strong></li>
<li><strong><a href="#Size">Size</a></strong></li>
</ul>
</li><li class="attribute">volumesCount:  (<strong><a href="#int">int</a></strong>): The number of volumes based on this template.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeTemplateDescribe">Describe a single volume template (<strong>VolumeTemplateDescribe</strong>)</h3>
<p>Same as VolumeTemplatesList but only return information about a given template.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeTemplateDescribe/{templateName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplateDescribe/{templateName}</em></li>
<li>Arguments: 
<ul>
<li>templateName - <strong>VolumeTemplateName</strong>: <em>a string(200), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "bw": <var>Bandwidth</var>,
    "id": <var>int</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeTemplateName</var>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": Either(<var>&quot;-&quot;</var>, <var>Replication</var>),
    "reuseServer": <var>bool</var> <span class="opt">/* Optional */</span>,
    "size": Either(<var>&quot;-&quot;</var>, <var>Size</var>)
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeTemplateDesc</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The name of the template.</li><li class="attribute">parentName:  The name of the snapshot on which volumes will be based.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  A default number of copies to be kept by StorPool.The value must be of one of the following types: &quot;-&quot;, Replication.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;-&quot;">&quot;-&quot;</a></strong></li>
<li><strong><a href="#Replication">Replication</a></strong></li>
</ul>
</li><li class="attribute">reuseServer:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): allow placement of replicas on same server.</li><li class="attribute">size:  A default size for the volumes (in bytes).The value must be of one of the following types: &quot;-&quot;, Size.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;-&quot;">&quot;-&quot;</a></strong></li>
<li><strong><a href="#Size">Size</a></strong></li>
</ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeTemplateCreate">Create a volume template (<strong>VolumeTemplateCreate</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeTemplateCreate HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "bw": <var>Bandwidth</var> <span class="opt">/* Optional */</span>,
  "iops": <var>IOPS</var> <span class="opt">/* Optional */</span>,
  "name": <var>VolumeTemplateName</var>,
  "parent": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeHead": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "reuseServer": <var>bool</var> <span class="opt">/* Optional */</span>,
  "size": <var>Size</var> <span class="opt">/* Optional */</span>,
  "tags": {
    "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
  } <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplateCreate</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>VolumeTemplateCreateDesc</strong><ul>
<li class="attribute">bw:  (<span class="opt">Optional</span> <strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<span class="opt">Optional</span> <strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The name of the new template.</li><li class="attribute">parent:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot on which to base volumes created by this template.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">reuseServer:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): allow placement of replicas on same server.</li><li class="attribute">size:  (<span class="opt">Optional</span> <strong><a href="#Size">Size</a></strong>): A default size for the volumes (in bytes).</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Optional name=value tags.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeTemplateUpdate">Update a volume template (<strong>VolumeTemplateUpdate</strong>)</h3>
<p>Alter the configuration of an existing volume template.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeTemplateUpdate/{templateName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "bw": <var>Bandwidth</var> <span class="opt">/* Optional */</span>,
  "iops": <var>IOPS</var> <span class="opt">/* Optional */</span>,
  "parent": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeHead": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "propagate": <var>bool</var> <span class="opt">/* Optional */</span>,
  "rename": <var>VolumeTemplateName</var> <span class="opt">/* Optional */</span>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "reuseServer": <var>bool</var> <span class="opt">/* Optional */</span>,
  "size": <var>Size</var> <span class="opt">/* Optional */</span>,
  "tags": {
    "<var>VolumeTagName</var>": <var>VolumeTagValue</var>, ...
  } <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplateUpdate/{templateName}</em></li>
<li>Arguments: 
<ul>
<li>templateName - <strong>VolumeTemplateName</strong>: <em>a string(200), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeTemplateUpdateDesc</strong><ul>
<li class="attribute">bw:  (<span class="opt">Optional</span> <strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<span class="opt">Optional</span> <strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">parent:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot on which to base volumes created by this template.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">propagate:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): Whether to propagate this change to all the volumes and snapshots using this template.</li><li class="attribute">rename:  (<span class="opt">Optional</span> <strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The new name of the template.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">reuseServer:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): allow placement of replicas on same server.</li><li class="attribute">size:  (<span class="opt">Optional</span> <strong><a href="#Size">Size</a></strong>): A default size for the volumes (in bytes).</li><li class="attribute">tags:  (<span class="opt">Optional</span> <strong><a href="#{VolumeTagName: VolumeTagValue}">{VolumeTagName: VolumeTagValue}</a></strong>): Optional name=value tags.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeTemplateDelete">Delete a volume template (<strong>VolumeTemplateDelete</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeTemplateDelete/{templateName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplateDelete/{templateName}</em></li>
<li>Arguments: 
<ul>
<li>templateName - <strong>VolumeTemplateName</strong>: <em>a string(200), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Volume-Relocator">Volume Relocator</h2>
<p>This is a service that moves data when needed, e.g. when
removing or adding disks.</p>
<h3 id="VolumeRelocatorStatus">Get the relocator&apos;s status (<strong>VolumeRelocatorStatus</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeRelocatorStatus HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeRelocatorStatus</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "status": <var>RelocatorStatus</var>,
    "volumesToRelocate": <var>int</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeRelocatorStatus</strong><ul>
<li class="attribute">status:  (<strong><a href="#RelocatorStatus">RelocatorStatus</a></strong>): &apos;off&apos; - relocator is currently turned off. &apos;on&apos; - relocator is on. &apos;blocked&apos; - relocation is blocked, most likely due to missing drives.</li><li class="attribute">volumesToRelocate:  (<strong><a href="#int">int</a></strong>): Number of volumes currently being relocated.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeRelocatorDisksList">List total per disk relocation estimates (<strong>VolumeRelocatorDisksList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeRelocatorDisksList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeRelocatorDisksList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>DiskID</var>": Either({
      "generationLeft": <var>-1</var>,
      "id": <var>DiskID</var>,
      "objectsAllocated": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "objectsCount": <var>int</var>,
      "onDiskSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "serverId": <var>ServerID</var>,
      "storedSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      }
    }, {
      "generationLeft": <var>long</var>,
      "id": <var>DiskID</var>,
      "serverId": <var>ServerID</var>
    }), ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from DiskID to Either(UpDiskTarget, DownDiskTarget)
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: The value must be of one of the following types: UpDiskTarget, DownDiskTarget.
<ul><em>Subtypes:</em>
<li><strong>UpDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server. -1 since the disk is currently up.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">objectsAllocated:  Statistics about the amount of objects to be allocated on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">onDiskSize:  Statistics about the total amount of space occupied by the objects on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li><li class="attribute">storedSize:  Statistics about the amount of cilent data to be stored on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li></ul>
</li>
<li><strong>DownDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeRelocatorVolumeDisks">List per disk relocation estimates for a given volume (<strong>VolumeRelocatorVolumeDisks</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeRelocatorVolumeDisks/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeRelocatorVolumeDisks/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>DiskID</var>": Either({
      "generationLeft": <var>-1</var>,
      "id": <var>DiskID</var>,
      "objectsAllocated": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "objectsCount": <var>int</var>,
      "onDiskSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "serverId": <var>ServerID</var>,
      "storedSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      }
    }, {
      "generationLeft": <var>long</var>,
      "id": <var>DiskID</var>,
      "serverId": <var>ServerID</var>
    }), ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from DiskID to Either(UpDiskTarget, DownDiskTarget)
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: The value must be of one of the following types: UpDiskTarget, DownDiskTarget.
<ul><em>Subtypes:</em>
<li><strong>UpDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server. -1 since the disk is currently up.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">objectsAllocated:  Statistics about the amount of objects to be allocated on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">onDiskSize:  Statistics about the total amount of space occupied by the objects on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li><li class="attribute">storedSize:  Statistics about the amount of cilent data to be stored on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li></ul>
</li>
<li><strong>DownDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeRelocatorSnapshotDisks">List per disk relocation estimates for a given snapshot (<strong>VolumeRelocatorSnapshotDisks</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeRelocatorSnapshotDisks/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeRelocatorSnapshotDisks/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>DiskID</var>": Either({
      "generationLeft": <var>-1</var>,
      "id": <var>DiskID</var>,
      "objectsAllocated": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "objectsCount": <var>int</var>,
      "onDiskSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "serverId": <var>ServerID</var>,
      "storedSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      }
    }, {
      "generationLeft": <var>long</var>,
      "id": <var>DiskID</var>,
      "serverId": <var>ServerID</var>
    }), ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from DiskID to Either(UpDiskTarget, DownDiskTarget)
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: The value must be of one of the following types: UpDiskTarget, DownDiskTarget.
<ul><em>Subtypes:</em>
<li><strong>UpDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server. -1 since the disk is currently up.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">objectsAllocated:  Statistics about the amount of objects to be allocated on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">onDiskSize:  Statistics about the total amount of space occupied by the objects on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li><li class="attribute">storedSize:  Statistics about the amount of cilent data to be stored on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li></ul>
</li>
<li><strong>DownDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Balancer">Balancer</h2>
<p>This is a service that decides when it is a good time to move data.</p>
<h3 id="VolumeBalancerStatus">Get the balancer&apos;s status (<strong>VolumeBalancerStatus</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeBalancerStatus HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerStatus</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "auto": <var>bool</var>,
    "status": <var>BalancerStatus</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeBalancerStatus</strong><ul>
<li class="attribute">auto:  (<strong><a href="#bool">bool</a></strong>): Is balancer running in automatic mode.</li><li class="attribute">status:  (<strong><a href="#BalancerStatus">BalancerStatus</a></strong>): The current balancer status.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBalancerStatus">Set the balancer&apos;s status (<strong>VolumeBalancerStatus</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeBalancerStatus HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "cmd": <var>BalancerCommand</var>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerStatus</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>VolumeBalancerCommand</strong><ul>
<li class="attribute">cmd:  (<strong><a href="#BalancerCommand">BalancerCommand</a></strong>): The command for the balacer to execute. &apos;start&apos; - run the balancer. &apos;stop&apos; - abort current run. &apos;commit&apos; - commit volume allocation changes.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBalancerVolumesStatus">List balancer volume and snapshot status (<strong>VolumeBalancerVolumesStatus</strong>)</h3>
<p>Show which volumes and snapshots will be reallocated by the
	current balancer run.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeBalancerVolumesStatus HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerVolumesStatus</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "blocked": <var>bool</var>,
    "name": Either(<var>VolumeName</var>, <var>SnapshotName</var>),
    "objectsCount": <var>int</var>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "reallocated": <var>bool</var>,
    "replication": <var>Replication</var>,
    "size": <var>long</var>,
    "snapshot": <var>bool</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>VolumeBalancerVolumeStatus</strong><ul>
<li class="attribute">blocked:  (<strong><a href="#bool">bool</a></strong>): Can this volume be rebalanced, or is rebalancing impossible with the current placement policy due to for example missing or soft-ejecting drives.</li><li class="attribute">name:  The volume&apos;s name.The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">reallocated:  (<strong><a href="#bool">bool</a></strong>): is this volume/snapshot going to reallocated by the balancing procedure.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#long">long</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">snapshot:  (<strong><a href="#bool">bool</a></strong>): True if this response describes a snapshot instead of a volume.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBalancerDisksList">List total per disk rebalancing estimates (<strong>VolumeBalancerDisksList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeBalancerDisksList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerDisksList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>DiskID</var>": Either({
      "generationLeft": <var>-1</var>,
      "id": <var>DiskID</var>,
      "objectsAllocated": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "objectsCount": <var>int</var>,
      "onDiskSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "serverId": <var>ServerID</var>,
      "storedSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      }
    }, {
      "generationLeft": <var>long</var>,
      "id": <var>DiskID</var>,
      "serverId": <var>ServerID</var>
    }), ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from DiskID to Either(UpDiskTarget, DownDiskTarget)
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: The value must be of one of the following types: UpDiskTarget, DownDiskTarget.
<ul><em>Subtypes:</em>
<li><strong>UpDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server. -1 since the disk is currently up.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">objectsAllocated:  Statistics about the amount of objects to be allocated on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">onDiskSize:  Statistics about the total amount of space occupied by the objects on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li><li class="attribute">storedSize:  Statistics about the amount of cilent data to be stored on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li></ul>
</li>
<li><strong>DownDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBalancerVolumeDisks">List per disk rebalancing estimated for a given volume (<strong>VolumeBalancerVolumeDisks</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeBalancerVolumeDisks/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerVolumeDisks/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>DiskID</var>": Either({
      "generationLeft": <var>-1</var>,
      "id": <var>DiskID</var>,
      "objectsAllocated": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "objectsCount": <var>int</var>,
      "onDiskSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "serverId": <var>ServerID</var>,
      "storedSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      }
    }, {
      "generationLeft": <var>long</var>,
      "id": <var>DiskID</var>,
      "serverId": <var>ServerID</var>
    }), ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from DiskID to Either(UpDiskTarget, DownDiskTarget)
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: The value must be of one of the following types: UpDiskTarget, DownDiskTarget.
<ul><em>Subtypes:</em>
<li><strong>UpDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server. -1 since the disk is currently up.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">objectsAllocated:  Statistics about the amount of objects to be allocated on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">onDiskSize:  Statistics about the total amount of space occupied by the objects on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li><li class="attribute">storedSize:  Statistics about the amount of cilent data to be stored on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li></ul>
</li>
<li><strong>DownDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBalancerSnapshotDisks">List per disk rebalancing estimates for a given snapshot (<strong>VolumeBalancerSnapshotDisks</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeBalancerSnapshotDisks/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerSnapshotDisks/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>DiskID</var>": Either({
      "generationLeft": <var>-1</var>,
      "id": <var>DiskID</var>,
      "objectsAllocated": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "objectsCount": <var>int</var>,
      "onDiskSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      },
      "serverId": <var>ServerID</var>,
      "storedSize": {
        "current": <var>int</var>,
        "delta": <var>int</var>,
        "target": <var>int</var>,
        "toRecover": <var>int</var>
      }
    }, {
      "generationLeft": <var>long</var>,
      "id": <var>DiskID</var>,
      "serverId": <var>ServerID</var>
    }), ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from DiskID to Either(UpDiskTarget, DownDiskTarget)
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: The value must be of one of the following types: UpDiskTarget, DownDiskTarget.
<ul><em>Subtypes:</em>
<li><strong>UpDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#-1">-1</a></strong>): The last cluster generation when the disk was active on a running server. -1 since the disk is currently up.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">objectsAllocated:  Statistics about the amount of objects to be allocated on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">onDiskSize:  Statistics about the total amount of space occupied by the objects on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li><li class="attribute">storedSize:  Statistics about the amount of cilent data to be stored on this disk.<ul>
<li class="attribute">current:  (<strong><a href="#int">int</a></strong>): The current value.</li><li class="attribute">delta:  (<strong><a href="#int">int</a></strong>): The difference between the target and current values.</li><li class="attribute">target:  (<strong><a href="#int">int</a></strong>): The target value.</li><li class="attribute">toRecover:  (<strong><a href="#int">int</a></strong>): The amount that will have to be recovered to get from the current to the target state.</li></ul>
</li></ul>
</li>
<li><strong>DownDiskTarget</strong><ul>
<li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>): The ID of this disk.</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the server this disk was last on.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBalancerVolumeDiskSets">Get the disk sets computed by the balancer for a given volume (<strong>VolumeBalancerVolumeDiskSets</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeBalancerVolumeDiskSets/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerVolumeDiskSets/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "balancerDiskSets": [[<var>DiskID</var>, ...], ...],
    "blocked": <var>bool</var>,
    "currentDiskSets": [[<var>DiskID</var>, ...], ...],
    "name": Either(<var>VolumeName</var>, <var>SnapshotName</var>),
    "objectsCount": <var>int</var>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "reallocated": <var>bool</var>,
    "replication": <var>Replication</var>,
    "size": <var>long</var>,
    "snapshot": <var>bool</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeBalancerVolumeDiskSets</strong><ul>
<li class="attribute">balancerDiskSets:  The new sets of disks that the volume&apos;s data should be stored on according to the rebalancing algorithm.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">blocked:  (<strong><a href="#bool">bool</a></strong>): Can this volume be rebalanced, or is rebalancing impossible with the current placement policy due to for example missing or soft-ejecting drives.</li><li class="attribute">currentDiskSets:  The current sets of disks that the volume&apos;s data should be stored on.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">name:  The volume&apos;s name.The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">reallocated:  (<strong><a href="#bool">bool</a></strong>): is this volume/snapshot going to reallocated by the balancing procedure.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#long">long</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">snapshot:  (<strong><a href="#bool">bool</a></strong>): True if this response describes a snapshot instead of a volume.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBalancerSnapshotDiskSets">Get the disk sets computed by the balancer for a given snapshot (<strong>VolumeBalancerSnapshotDiskSets</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeBalancerSnapshotDiskSets/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerSnapshotDiskSets/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "balancerDiskSets": [[<var>DiskID</var>, ...], ...],
    "blocked": <var>bool</var>,
    "currentDiskSets": [[<var>DiskID</var>, ...], ...],
    "name": Either(<var>VolumeName</var>, <var>SnapshotName</var>),
    "objectsCount": <var>int</var>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "reallocated": <var>bool</var>,
    "replication": <var>Replication</var>,
    "size": <var>long</var>,
    "snapshot": <var>bool</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeBalancerVolumeDiskSets</strong><ul>
<li class="attribute">balancerDiskSets:  The new sets of disks that the volume&apos;s data should be stored on according to the rebalancing algorithm.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">blocked:  (<strong><a href="#bool">bool</a></strong>): Can this volume be rebalanced, or is rebalancing impossible with the current placement policy due to for example missing or soft-ejecting drives.</li><li class="attribute">currentDiskSets:  The current sets of disks that the volume&apos;s data should be stored on.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">name:  The volume&apos;s name.The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">reallocated:  (<strong><a href="#bool">bool</a></strong>): is this volume/snapshot going to reallocated by the balancing procedure.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#long">long</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">snapshot:  (<strong><a href="#bool">bool</a></strong>): True if this response describes a snapshot instead of a volume.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBalancerGroups">List balancer allocation groups (<strong>VolumeBalancerGroups</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeBalancerGroups HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerGroups</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "blocked": <var>bool</var>,
    "feasible": <var>bool</var>,
    "objectsCount": <var>int</var>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeHead": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "reuseServer": <var>bool</var> <span class="opt">/* Optional */</span>,
    "root": Either(<var>VolumeName</var>, <var>SnapshotName</var>),
    "size": <var>int</var>,
    "slots": [{
      "objectsCount": <var>int</var>,
      "storedSize": <var>int</var>
    }, ...],
    "storedSize": <var>int</var>,
    "targetDiskSets": [[<var>DiskID</var>, ...], ...],
    "volumes": [Either(<var>VolumeName</var>, <var>SnapshotName</var>), ...]
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>VolumeBalancerAllocationGroup</strong><ul>
<li class="attribute">blocked:  (<strong><a href="#bool">bool</a></strong>): Can this volume be rebalanced, or is rebalancing impossible with the current placement policy due to for example missing or soft-ejecting drives.</li><li class="attribute">feasible:  (<strong><a href="#bool">bool</a></strong>): Can new volumes be allocated with the current placement policy and redundancy constraints.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The total number of objects of all volumes and snapshots in the group.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeHead:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the first replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">reuseServer:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): allow placement of replicas on same server</li><li class="attribute">root:  The name of this group&apos;s root volume or snapshotThe value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">size:  (<strong><a href="#int">int</a></strong>): The total size of all volumes and snapshots in the group.</li><li class="attribute">slots:  Statistics about each of the current disk sets.<ul>Element type: <strong>VolumeBalancerSlot</strong><ul>
<li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): Number of objects on the corresponding disk set.</li><li class="attribute">storedSize:  (<strong><a href="#int">int</a></strong>): Number of bytes of client data stored on the corresponding disk set.</li></ul>

</li></ul>
</li><li class="attribute">storedSize:  (<strong><a href="#int">int</a></strong>): The total number of bytes of client data on all volumes and  snapshots in this group.</li><li class="attribute">targetDiskSets:  The current sets of disks that the volume&apos;s data should be stored on.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">volumes:  The names of all volumes and snapshots in this group.<ul>Element type: The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>

</li></ul>
</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="iSCSI">iSCSI</h2>
<p></p>
<h3 id="iSCSIConfig">Get the StorPool iSCSI configuration (<strong>iSCSIConfig</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/iSCSIConfig HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/iSCSIConfig</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "iscsi": {
      "baseName": <var>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</var>,
      "initiators": {
        "<var>iSCSIId</var>": {
          "exports": [{
            "portalGroup": <var>str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</var>,
            "target": <var>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</var>
          }, ...],
          "name": <var>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</var>,
          "nets": [<var>string</var>, ...],
          "secret": <var>string</var>,
          "username": <var>string</var>
        }, ...
      },
      "portalGroups": {
        "<var>int</var>": {
          "name": <var>str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</var>,
          "networks": [{
            "address": <var>string</var>,
            "prefix": <var>int</var>
          }, ...],
          "portals": [{
            "controller": <var>iSCSIId</var>,
            "ip": <var>string</var>,
            "port": <var>string</var>
          }, ...]
        }, ...
      },
      "targets": {
        "<var>int</var>": {
          "currentControllerId": <var>int</var>,
          "name": <var>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</var>,
          "volume": <var>VolumeName</var>
        }, ...
      }
    }
  }
}
</code></pre></li>
<li>Response Data:
<strong>iSCSIConfig</strong><ul>
<li class="attribute">iscsi:  The actual configuration data<ul>
<li class="attribute">baseName:  (<strong><a href="#str, default=&quot;^[a-z0-9\\-.:]+$&quot;">str, default=&quot;^[a-z0-9\\-.:]+$&quot;</a></strong>): The StorPool cluster&apos;s iSCSI base name.</li><li class="attribute">initiators:  The iSCSI initiators allowed to access the cluster.A dict from iSCSIId to iSCSIInitiator
<ul>
<li>Key type: <strong><a href="#iSCSIId">iSCSIId</a></strong></li>
<li>Value type: <strong>iSCSIInitiator</strong><ul>
<li class="attribute">exports: <ul>Element type: <strong>iSCSIExport</strong><ul>
<li class="attribute">portalGroup:  (<strong><a href="#str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;">str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</a></strong>): The portal group exporting this volume.</li><li class="attribute">target:  (<strong><a href="#str, default=&quot;^[a-z0-9\\-.:]+$&quot;">str, default=&quot;^[a-z0-9\\-.:]+$&quot;</a></strong>): The target exporting this volume.</li></ul>

</li></ul>
</li><li class="attribute">name:  (<strong><a href="#str, default=&quot;^[a-z0-9\\-.:]+$&quot;">str, default=&quot;^[a-z0-9\\-.:]+$&quot;</a></strong>): The iSCSI initiator&apos;s IQN.</li><li class="attribute">nets:  The networks this initiator will contact the iSCSI cluster on.<ul>Element type: <strong><a href="#string">string</a></strong>
</li></ul>
</li><li class="attribute">secret:  (<strong><a href="#string">string</a></strong>): The password to authenticate the initiator with.</li><li class="attribute">username:  (<strong><a href="#string">string</a></strong>)</li></ul>
</li>
</ul>
</li><li class="attribute">portalGroups:  The iSCSI portal groups defined for the cluster.A dict from int to iSCSIPortalGroup
<ul>
<li>Key type: <strong><a href="#int">int</a></strong></li>
<li>Value type: <strong>iSCSIPortalGroup</strong><ul>
<li class="attribute">name:  (<strong><a href="#str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;">str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</a></strong>): The iSCSI portal group name.</li><li class="attribute">networks:  The networks this portal group is accessible on.<ul>Element type: <strong>iSCSIPGNetwork</strong><ul>
<li class="attribute">address:  (<strong><a href="#string">string</a></strong>): The dotted-quad network address.</li><li class="attribute">prefix:  (<strong><a href="#int">int</a></strong>): The network&apos;s CIDR prefix length.</li></ul>

</li></ul>
</li><li class="attribute">portals:  The list of portals defined in this group.<ul>Element type: <strong>iSCSIPortal</strong><ul>
<li class="attribute">controller:  (<strong><a href="#iSCSIId">iSCSIId</a></strong>): The StorPool iSCSI target service handling this portal.</li><li class="attribute">ip:  (<strong><a href="#string">string</a></strong>): The IP address for the portal.</li><li class="attribute">port:  (<strong><a href="#string">string</a></strong>): The TCP port for the portal.</li></ul>

</li></ul>
</li></ul>
</li>
</ul>
</li><li class="attribute">targets: A dict from int to iSCSITarget
<ul>
<li>Key type: <strong><a href="#int">int</a></strong></li>
<li>Value type: <strong>iSCSITarget</strong><ul>
<li class="attribute">currentControllerId:  (<strong><a href="#int">int</a></strong>): the StorPool iSCSI target service handling this target.</li><li class="attribute">name:  (<strong><a href="#str, default=&quot;^[a-z0-9\\-.:]+$&quot;">str, default=&quot;^[a-z0-9\\-.:]+$&quot;</a></strong>): The iSCSI name that the target is exposed as.</li><li class="attribute">volume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the StorPool volume being exposed.</li></ul>
</li>
</ul>
</li></ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="iSCSIConfig">Modify the StorPool iSCSI configuration (<strong>iSCSIConfig</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/iSCSIConfig HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "commands": [{
    "createInitiator": {
      "name": <var>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</var>,
      "secret": <var>string</var>,
      "username": <var>string</var>
    } <span class="opt">/* Optional */</span>,
    "createPortal": {
      "controller": <var>iSCSIId</var>,
      "ip": <var>string</var>,
      "port": <var>int</var> <span class="opt">/* Optional */</span>,
      "portalGroup": <var>str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</var>
    } <span class="opt">/* Optional */</span>,
    "createPortalGroup": {
      "name": <var>str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</var>
    } <span class="opt">/* Optional */</span>,
    "createTarget": {
      "volumeName": <var>VolumeName</var>
    } <span class="opt">/* Optional */</span>,
    "deleteInitiator": {
      "name": <var>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</var>
    } <span class="opt">/* Optional */</span>,
    "deletePortal": {
      "ip": <var>string</var>,
      "port": <var>int</var> <span class="opt">/* Optional */</span>
    } <span class="opt">/* Optional */</span>,
    "deletePortalGroup": {
      "name": <var>str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</var>
    } <span class="opt">/* Optional */</span>,
    "deleteTarget": {
      "volumeName": <var>VolumeName</var>
    } <span class="opt">/* Optional */</span>,
    "export": {
      "initiator": <var>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</var>,
      "portalGroup": <var>str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</var>,
      "volumeName": <var>VolumeName</var>
    } <span class="opt">/* Optional */</span>,
    "exportDelete": {
      "initiator": <var>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</var>,
      "portalGroup": <var>str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</var>,
      "volumeName": <var>VolumeName</var>
    } <span class="opt">/* Optional */</span>,
    "initiatorAddNetwork": {
      "initiator": <var>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</var>,
      "net": <var>string</var>
    } <span class="opt">/* Optional */</span>,
    "portalGroupAddNetwork": {
      "net": <var>string</var>,
      "portalGroup": <var>str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</var>
    } <span class="opt">/* Optional */</span>,
    "setBaseName": {
      "name": <var>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</var>
    } <span class="opt">/* Optional */</span>
  }, ...]
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/iSCSIConfig</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>iSCSIConfigChange</strong><ul>
<li class="attribute">commands:  The actual iSCSI configuration commands.<ul>Element type: <strong>iSCSIConfigCommand</strong><ul>
<li class="attribute">createInitiator:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandCreateInitiator">iSCSICommandCreateInitiator</a></strong>): Define an iSCSI initiator that will connect to the cluster.</li><li class="attribute">createPortal:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandCreatePortal">iSCSICommandCreatePortal</a></strong>): Create an iSCSI portal.</li><li class="attribute">createPortalGroup:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandCreatePortalGroup">iSCSICommandCreatePortalGroup</a></strong>): Create an iSCSI portal group.</li><li class="attribute">createTarget:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandCreateTarget">iSCSICommandCreateTarget</a></strong>): Create an iSCSI target for a StorPool volume.</li><li class="attribute">deleteInitiator:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandDeleteInitiator">iSCSICommandDeleteInitiator</a></strong>): Delete an iSCSI initiator definition.</li><li class="attribute">deletePortal:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandDeletePortal">iSCSICommandDeletePortal</a></strong>): Delete a previously created iSCSI portal.</li><li class="attribute">deletePortalGroup:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandDeletePortalGroup">iSCSICommandDeletePortalGroup</a></strong>): Delete a previously created iSCSI portal group.</li><li class="attribute">deleteTarget:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandDeleteTarget">iSCSICommandDeleteTarget</a></strong>): Delete the iSCSI target for a StorPool volume.</li><li class="attribute">export:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandExport">iSCSICommandExport</a></strong>): Export a StorPool volume (with an already created target) via iSCSI.</li><li class="attribute">exportDelete:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandExportDelete">iSCSICommandExportDelete</a></strong>): Stop exporting a StorPool volume via iSCSI.</li><li class="attribute">initiatorAddNetwork:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandInitiatorAddNetwork">iSCSICommandInitiatorAddNetwork</a></strong>): Define a network that an iSCSI initiator will connect to the cluster on.</li><li class="attribute">portalGroupAddNetwork:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandPortalGroupAddNetwork">iSCSICommandPortalGroupAddNetwork</a></strong>): Add a CIDR network specification to a portal group.</li><li class="attribute">setBaseName:  (<span class="opt">Optional</span> <strong><a href="#iSCSICommandSetBaseName">iSCSICommandSetBaseName</a></strong>): Set the StorPool cluster&apos;s iSCSI base name.</li></ul>

</li></ul>
</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "info": <var>string</var> <span class="opt">/* Optional */</span>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">info:  (<span class="opt">Optional</span> <strong><a href="#string">string</a></strong>): May contain additional information about the request.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Remote">Remote</h2>
<p></p>
<h3 id="LocationsList">List the registered remote locations (<strong>LocationsList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/LocationsList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/LocationsList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>str, default=&quot;locations&quot;</var>": [{
      "id": <var>Global Location Id</var>,
      "name": <var>RemoteLocationName</var>
    }, ...], ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from str, default=&quot;locations&quot; to [RemoteLocation]
<ul>
<li>Key type: <strong><a href="#str, default=&quot;locations&quot;">str, default=&quot;locations&quot;</a></strong></li>
<li>Value type: <ul>Element type: <strong>RemoteLocation</strong><ul>
<li class="attribute">id:  (<strong><a href="#Global Location Id">Global Location Id</a></strong>): A StorPool-provided unique location id.</li><li class="attribute">name:  (<strong><a href="#RemoteLocationName">RemoteLocationName</a></strong>): The human-readable location name.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="types">Data Types</h2>
<table>
<tr id="&quot;&quot;"><td><strong>&quot;&quot;</strong>:</td><td>The constant value &quot;&quot;.</td></tr>
<tr id="&quot;-&quot;"><td><strong>&quot;-&quot;</strong>:</td><td>The constant value &quot;-&quot;.</td></tr>
<tr id="&quot;all&quot;"><td><strong>&quot;all&quot;</strong>:</td><td>The constant value &quot;all&quot;.</td></tr>
<tr id="-1"><td><strong>-1</strong>:</td><td>The constant value -1.</td></tr>
<tr id="0"><td><strong>0</strong>:</td><td>The constant value 0.</td></tr>
<tr id="AttachmentPos"><td><strong>AttachmentPos</strong>:</td><td>integer, 0 &lt;= value &lt;= 1023</td></tr>
<tr id="AttachmentRights"><td><strong>AttachmentRights</strong>:</td><td>One of {&quot;rw&quot;, &quot;ro&quot;}</td></tr>
<tr id="BalancerCommand"><td><strong>BalancerCommand</strong>:</td><td>One of {&quot;start&quot;, &quot;stop&quot;, &quot;commit&quot;}</td></tr>
<tr id="BalancerStatus"><td><strong>BalancerStatus</strong>:</td><td>One of {&quot;nothing to do&quot;, &quot;blocked&quot;, &quot;waiting&quot;, &quot;working&quot;, &quot;ready&quot;, &quot;commiting&quot;}</td></tr>
<tr id="Bandwidth"><td><strong>Bandwidth</strong>:</td><td>a positive integer or &apos;-&apos; for unlimited</td></tr>
<tr id="BeaconClusterStatus"><td><strong>BeaconClusterStatus</strong>:</td><td>One of {&quot;CNODE_DOWN&quot;, &quot;CNODE_DAMPING&quot;, &quot;CNODE_UP&quot;}</td></tr>
<tr id="BeaconNodeStatus"><td><strong>BeaconNodeStatus</strong>:</td><td>One of {&quot;NODE_DOWN&quot;, &quot;NODE_UP&quot;}</td></tr>
<tr id="BridgeId"><td><strong>BridgeId</strong>:</td><td>integer, 1 &lt;= value &lt;= 4096</td></tr>
<tr id="BridgeStatus"><td><strong>BridgeStatus</strong>:</td><td>One of {&quot;running&quot;, &quot;joining&quot;, &quot;down&quot;}</td></tr>
<tr id="ClientID"><td><strong>ClientID</strong>:</td><td>integer, 1 &lt;= value &lt;= 4096</td></tr>
<tr id="ClientStatus"><td><strong>ClientStatus</strong>:</td><td>One of {&quot;running&quot;, &quot;down&quot;}</td></tr>
<tr id="ClusterStatus"><td><strong>ClusterStatus</strong>:</td><td>One of {&quot;running&quot;, &quot;waiting&quot;, &quot;down&quot;}</td></tr>
<tr id="DiskDescritpion"><td><strong>DiskDescritpion</strong>:</td><td>string, regex ^[A-Za-z0-9_\- ]{,30}$</td></tr>
<tr id="DiskID"><td><strong>DiskID</strong>:</td><td>integer, 0 &lt;= value &lt;= 4095</td></tr>
<tr id="DiskSoftEjectStatus"><td><strong>DiskSoftEjectStatus</strong>:</td><td>One of {&quot;on&quot;, &quot;off&quot;, &quot;paused&quot;}</td></tr>
<tr id="GUID"><td><strong>GUID</strong>:</td><td>string, regex ^0x[0-9a-fA-F]{2,16}$</td></tr>
<tr id="Global Location Id"><td><strong>Global Location Id</strong>:</td><td>string, regex [a-z0-9]+$</td></tr>
<tr id="Global Volume Id"><td><strong>Global Volume Id</strong>:</td><td>string, regex [a-z0-9]+\.[a-z0-9]\.[a-z0-9]+$</td></tr>
<tr id="IOPS"><td><strong>IOPS</strong>:</td><td>a positive integer or &apos;-&apos; for unlimited</td></tr>
<tr id="MAC Address"><td><strong>MAC Address</strong>:</td><td>string, regex ^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$</td></tr>
<tr id="MgmtID"><td><strong>MgmtID</strong>:</td><td>integer, 1 &lt;= value &lt;= 4096</td></tr>
<tr id="NetID"><td><strong>NetID</strong>:</td><td>integer, 0 &lt;= value &lt;= 3</td></tr>
<tr id="NodeID"><td><strong>NodeID</strong>:</td><td>integer, 0 &lt;= value &lt;= 63</td></tr>
<tr id="ObjectState"><td><strong>ObjectState</strong>:</td><td>ObjectState, enumeration from 0 to 9</td></tr>
<tr id="PeerID"><td><strong>PeerID</strong>:</td><td>integer, 0 &lt;= value &lt;= 65535</td></tr>
<tr id="PeerStatus"><td><strong>PeerStatus</strong>:</td><td>One of {&quot;up&quot;, &quot;down&quot;}</td></tr>
<tr id="PlacementGroupName"><td><strong>PlacementGroupName</strong>:</td><td>a string(128), matching ^[A-Za-z0-9_\-]+$, except {list}</td></tr>
<tr id="RdmaState"><td><strong>RdmaState</strong>:</td><td>One of {&quot;Idle&quot;, &quot;GidReceived&quot;, &quot;Connecting&quot;, &quot;Connected&quot;, &quot;pendingError&quot;, &quot;Error&quot;}</td></tr>
<tr id="RelocatorStatus"><td><strong>RelocatorStatus</strong>:</td><td>One of {&quot;on&quot;, &quot;off&quot;, &quot;blocked&quot;}</td></tr>
<tr id="RemoteLocationName"><td><strong>RemoteLocationName</strong>:</td><td>a string(64), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list}</td></tr>
<tr id="Replication"><td><strong>Replication</strong>:</td><td>integer, 1 &lt;= value &lt;= 3</td></tr>
<tr id="RequestOp"><td><strong>RequestOp</strong>:</td><td>One of {&quot;read&quot;, &quot;write&quot;, &quot;merge&quot;, &quot;system&quot;, &quot;entries flush&quot;, &quot;#bad_state&quot;, &quot;#bad_drOp&quot;}</td></tr>
<tr id="ServerID"><td><strong>ServerID</strong>:</td><td>integer, 1 &lt;= value &lt;= 32767</td></tr>
<tr id="ServerStatus"><td><strong>ServerStatus</strong>:</td><td>One of {&quot;running&quot;, &quot;waiting&quot;, &quot;booting&quot;, &quot;down&quot;}</td></tr>
<tr id="Size"><td><strong>Size</strong>:</td><td>a positive integer divisible by 512</td></tr>
<tr id="SizeAdd"><td><strong>SizeAdd</strong>:</td><td>a positive integer divisible by 512</td></tr>
<tr id="SnapshotName"><td><strong>SnapshotName</strong>:</td><td>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</td></tr>
<tr id="VolumeCurentStatus"><td><strong>VolumeCurentStatus</strong>:</td><td>One of {&quot;up&quot;, &quot;up soon&quot;, &quot;data lost&quot;, &quot;down&quot;}</td></tr>
<tr id="VolumeName"><td><strong>VolumeName</strong>:</td><td>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</td></tr>
<tr id="VolumeTagName"><td><strong>VolumeTagName</strong>:</td><td>a string(200), matching ^[A-Za-z0-9_\-.:]+$, except {}</td></tr>
<tr id="VolumeTagValue"><td><strong>VolumeTagValue</strong>:</td><td>a string(200), matching ^[A-Za-z0-9_\-.:]*$, except {}</td></tr>
<tr id="VolumeTemplateName"><td><strong>VolumeTemplateName</strong>:</td><td>a string(200), matching ^[A-Za-z0-9_\-]+$, except {list}</td></tr>
<tr id="bool"><td><strong>bool</strong>:</td><td>true or false.</td></tr>
<tr id="bool, default=false"><td><strong>bool, default=false</strong>:</td><td>A value of type bool. Default value = False.</td></tr>
<tr id="client status"><td><strong>client status</strong>:</td><td>One of {&quot;ok&quot;, &quot;updating&quot;, &quot;down&quot;}</td></tr>
<tr id="float"><td><strong>float</strong>:</td><td>A floating point number.</td></tr>
<tr id="iSCSIId"><td><strong>iSCSIId</strong>:</td><td>integer, 0 &lt;= value &lt;= 4095</td></tr>
<tr id="int"><td><strong>int</strong>:</td><td>An integer value.</td></tr>
<tr id="long"><td><strong>long</strong>:</td><td>A long integer value.</td></tr>
<tr id="null"><td><strong>null</strong>:</td><td>The constant value null.</td></tr>
<tr id="str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;"><td><strong>str, default=&quot;^[A-Za-z0-9_\\-.:]+$&quot;</strong>:</td><td>A value of type str. Default value = ^[A-Za-z0-9_\-.:]+$.</td></tr>
<tr id="str, default=&quot;^[a-z0-9\\-.:]+$&quot;"><td><strong>str, default=&quot;^[a-z0-9\\-.:]+$&quot;</strong>:</td><td>A value of type str. Default value = ^[a-z0-9\-.:]+$.</td></tr>
<tr id="str, default=&quot;exports&quot;"><td><strong>str, default=&quot;exports&quot;</strong>:</td><td>A value of type str. Default value = exports.</td></tr>
<tr id="str, default=&quot;locations&quot;"><td><strong>str, default=&quot;locations&quot;</strong>:</td><td>A value of type str. Default value = locations.</td></tr>
<tr id="str, default=&quot;snapshots&quot;"><td><strong>str, default=&quot;snapshots&quot;</strong>:</td><td>A value of type str. Default value = snapshots.</td></tr>
<tr id="string"><td><strong>string</strong>:</td><td>A string value.</td></tr>
<tr id="true"><td><strong>true</strong>:</td><td>The constant value true.</td></tr>
</table>

	
	</body>
</html>

